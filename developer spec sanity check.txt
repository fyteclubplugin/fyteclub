# Syncshell Full Implementation Specification

This document is the authoritative implementation brief for the Syncshell
system. It consolidates all design requirements, constraints, and developer
instructions discussed so far.

---

## Core Principles

The Syncshell system is fully decentralized. There are no central servers,
no passwords, and no permanent external dependencies. Peers discover and
connect to each other using WebRTC, with STUN for NAT traversal. TURN relay
may be used only if volunteered by participants, but is not required.
TURN is also last for development, its not something we should worry about
unless we absolutely need it anyway.

Membership is based on cryptographically signed persistent tokens. An invite
is a one-time bootstrap artifact; tokens are the true credentials. Revocation
and expiry are supported. All data transfers are direct peer-to-peer.

---

## Lifecycle Flow

### Invite Creation
1. Host generates a WebRTC offer (`createOffer()`).
2. Wrap in invite JSON:
   ```json
   {
     "type":"offer",
     "group_id":"b32:ABCD...",
     "host_peer_id":"ed25519:HOST...",
     "offer_blob":"<gz+base64 SDP>",
     "ts":1725480000,
     "expiry":1725481800,
     "sig":"<host_sig>"
   }
   ```
3. Encode as QR/URL/base64. Invite is valid while host online or until expiry.

### Joiner Flow
1. Joiner decodes invite and verifies host signature.
2. Sets remote description, generates answer, and sends it back to host.
3. ICE exchange proceeds until WebRTC DataChannel established.

### Token Issuance
1. Host generates a signed `member_token` bound to joiner’s key:
   ```json
   {
     "token_v":1,
     "group_id":"b32:ABCD...",
     "member_pubkey":"ed25519:JOIN...",
     "issued_by":"ed25519:HOST...",
     "issued_at":<ts>,
     "expiry":<ts>,
     "nonce":"<rand>",
     "sig":"<host_sig_over_token>"
   }
   ```
2. Host sends token via the secure DataChannel.
3. Joiner verifies and stores token securely (keychain/DPAPI).

### Reconnection
1. Client presents token and proves possession of private key by signing a challenge.
2. Peer validates token signature and checks revocation/expiry.
3. If valid, peer accepts and ICE/WebRTC reconnection proceeds.

---

## Revocation and Tombstones

- Revocations are signed tombstone records:
  ```json
  {
    "peer_id":"ed25519:JOIN...",
    "entry_seq":42,
    "removed_by":"ed25519:HOST...",
    "ts":1725485000,
    "sig":"<sig>"
  }
  ```
- For small groups (<10), single-sig removal is enough.
- For larger groups, tombstones may require quorum signatures.
- Tombstones propagate in phonebook envelopes and invalidate tokens.

---

## Phonebook and Introducers

- Each syncshell maintains a signed phonebook mapping peer IDs to last-known
  IP, ports, and keys.
- Any member can act as introducer. If a joiner cannot reach the host directly,
  introducer forwards initial signaling until direct P2P established.
- Once phonebook is seeded, peers connect directly; the mesh is used only for
  discovery and healing.

---

## NAT Traversal

- Default: WebRTC ICE with STUN servers (public or community-operated).
- Optional: volunteer peers can provide TURN relays. No central TURN service.
- Goal: most peers succeed with direct UDP hole punching; TURN only as fallback.

---

## Scaling and Topology

- Star topology for small groups (host issues initial tokens).
- Mesh topology emerges after phonebook propagation (any peer can introduce).
- Large syncshells (>100) should expect higher signaling overhead. System is not
  designed for thousands of members, though technically possible.
- Mod data transfers are only peer-to-peer and only triggered by proximity and
  mod hash mismatch, not constant sync.

---

## Security Rules

1. All tokens and phonebook entries must be signed with Ed25519 keys.
2. Proof-of-possession required: clients sign nonce on reconnect.
3. Token expiry default: 6 months. Renewable.
4. Tombstones override tokens immediately.
5. Nonces prevent replay. Include `issued_at` in tokens.
6. Secure local storage of tokens and keys is mandatory.

---

## Timeouts and Defaults

- Invite validity: until host offline or 30 minutes max.
- Offer→Answer wait: 45s, 3 retries exponential backoff.
- Token expiry: 6 months.
- Phonebook entry TTL: 24 hours.
- Tombstone retention: 7 days.
- Rejoin failure backoff: 30s up to 1h; after 6 fails, require new invite.

---

## Example Envelopes

Invite:
```json
{
  "type":"offer",
  "group_id":"b32:ABCD...",
  "host_peer_id":"ed25519:HOST...",
  "offer_blob":"<gz+base64 SDP>",
  "ts":1725480000,
  "expiry":1725481800,
  "sig":"<host_sig>"
}
```

Member Credentials:
```json
{
  "type":"member_credentials",
  "group_id":"b32:ABCD...",
  "member_pubkey":"ed25519:JOIN...",
  "token":{...},
  "issued_by":"ed25519:HOST...",
  "ts":1725480100,
  "sig":"<host_sig_over_envelope>"
}
```

Reconnect Proof:
```json
{
  "type":"reconnect_proof",
  "group_id":"b32:ABCD...",
  "member_pubkey":"ed25519:JOIN...",
  "challenge_sig":"<signature_of_nonce_by_member_private_key>",
  "ts":1725590000
}
```

---

## Testing Requirements

- Invite flow: verify host signature, SDP set, ICE success, DataChannel open.
- Token issuance: host sends token, joiner verifies, stores, and reuses.
- Revocation: tombstone propagates, revoked token fails reconnect.
- Expiry: expired token rejected, requires new invite.
- IP churn: reconnect with same token after IP change must succeed.
- Token theft: token replay fails without private key proof.

---

## UX Expectations

- Users never enter passwords.
- Invite is a simple “share QR/link” step.
- Successful join is silent, token stored automatically.
- Reconnects are automatic using token.
- Failures provide clear messages: host offline, token expired, removed from group.

---

## Developer Notes

- No central server should exist. Everything must work P2P with STUN.
- TURN relay is optional and only community-run.
- Tokens are the single source of truth for membership. Invites are ephemeral.
- Always sign and verify all envelopes and records.
- Keep UX simple: complexity hidden from user.


Specification for engineers (goal-first, implementation-ready)

1) High-level goals
- Make a privacy-preserving, fully decentralized syncshell system that:
- Allows peers to discover and join groups without central servers
- Uses one-time invites for bootstrap, persistent cryptographic tokens for membership
- Ensures all mod/data transfers are direct P2P, with no relays required
- Supports NAT traversal automatically via WebRTC + STUN
- Allows secure rejoin, token revocation, and expiry
- Minimizes user-facing complexity; no visible passwords

2) Core primitives, crypto & formats
- Long-term identity keys (Ed25519) for every peer
- Signed tokens for membership proof and rejoin authentication
- Tombstones for revocation, with optional quorum signing
- All phonebook and token envelopes signed and optionally encrypted
- Invite encoding: WebRTC offer + metadata, base64/QR-friendly

3) Networking & WebRTC specifics
- Direct P2P connections for all traffic
- ICE with STUN for NAT traversal
- Optional TURN relay if volunteered; no central relay
- Invite flow: host createOffer -> joiner createAnswer -> ICE/DataChannel established
- Persistent token used for reconnects, eliminating repeated invites

4) Phonebook lifecycle & merges
- Each syncshell maintains a signed phonebook with peer IDs, IP/port, and keys
- Phonebook entries updated with every join/removal
- Merge conflicts resolved with sequence numbers or last-writer-wins
- Tombstones propagate through phonebook to remove revoked members

5) Host selection and lifecycle
- Initial host issues invites and tokens
- If host goes offline, introducers handle initial signaling
- Host role can persist for new joins while online
- Host failure does not prevent existing members from reconnecting

6) Membership, consensus & promotions
- Membership verified via signed tokens
- Revocation via signed tombstones; quorum required for larger groups
- Invitations, promotions, and removals propagate via phonebook

7) Rejoin prevention & rate-limiting
- Tokens tie to member key for proof-of-possession
- Failed reconnect attempts trigger exponential backoff (start 30s, max 1h)
- Rejoin prevented until new invite issued if backoff exceeded or token revoked

8) Multi-shell introducers (bridging) behavior
- Peers with multiple syncshells can act as introducers
- Introducers help new members connect without revealing identities outside their shells
- Introducer only relays signaling, not mod/data payloads

9) Topology & scaling rules
- Small groups: star topology around host
- Larger groups: mesh emerges after phonebook propagation
- Mod transfer always direct P2P; proximity and hash-based triggers only
- Very large groups (>1000) discouraged; overhead increases

10) Testing & validation plan
- Invite/answer flow validation
- Token issuance and verification
- Reconnect using token across IP changes
- Revocation and tombstone propagation
- Token expiry handling
- NAT traversal scenarios

11) Developer deliverables & checklist
- Fully signed token & envelope handling
- Phonebook management and merge logic
- WebRTC signaling integration
- STUN (and optional TURN) setup
- Rejoin/backoff mechanisms
- Revocation and tombstone propagation

12) UX guidance for devs
- Invite flow: simple share (QR/URL)
- Join is automatic and silent; token stored locally
- Clear error messages on failure: host offline, token expired, removed

13) Security & privacy checklist
- Sign all envelopes (tokens, phonebook, tombstones)
- Proof-of-possession on reconnects
- Secure local storage of private keys and tokens
- Replay protection with nonces and timestamps
- Optional token rotation

14) Quick reference default values (copy into config)
- Invite validity: 30 minutes or until host offline
- Offer→Answer wait: 45s, 3 retries exponential backoff
- Token expiry: 6 months
- Phonebook TTL: 24 hours
- Tombstone retention: 7 days
- Rejoin backoff: 30s → 1h, reset after 6 failures
