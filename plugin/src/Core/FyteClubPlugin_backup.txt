// This file has been modularized into separate partial class files:
// - FyteClubPluginCore.cs - Core initialization and dependency injection
// - FyteClubPlugin.SyncQueue.cs - Sync queue management
// - FyteClubPlugin.SyncshellManagement.cs - Syncshell operations
// - FyteClubPlugin.ModSharing.cs - Mod sharing functionality
// - FyteClubPlugin.Framework.cs - Framework updates and IPC
// - FyteClubPlugin.Configuration.cs - Configuration management
// - FyteClubPlugin.CacheManagement.cs - Cache operations
// - FyteClubPlugin.P2PConnections.cs - P2P connection handling
// - FyteClubPlugin.Commands.cs - Command processing

// The main plugin class is now in FyteClubPluginCore.cs
// This file is kept for reference but should be removed after migration

namespace FyteClub
{
    // DEPRECATED: Use FyteClubPluginCore.cs instead
    public sealed partial class FyteClubPlugin_DEPRECATED : IDalamudPlugin, IMediatorSubscriber
    {
        public string Name => "FyteClub";
        private const string CommandName = "/fyteclub";
        
        private readonly IDalamudPluginInterface _pluginInterface;
        private readonly ICommandManager _commandManager;
        private readonly IObjectTable _objectTable;
        private readonly IClientState _clientState;
        public readonly IFramework _framework;
        public readonly IPluginLog _pluginLog;
        
        private readonly FyteClubMediator _mediator = new();
        private readonly PlayerDetectionService _playerDetection;
        private readonly HttpClient _httpClient = new();
        private readonly WindowSystem _windowSystem;
        private readonly ConfigWindow _configWindow;
        private readonly FyteClubModIntegration _modSystemIntegration;
        private readonly FyteClubRedrawCoordinator _redrawCoordinator;
        private readonly SafeModIntegration _safeModIntegration;
        private readonly P2PModSyncOrchestrator _modSyncOrchestrator;
        public readonly SyncshellManager _syncshellManager;
        public readonly FyteClub.TURN.TurnServerManager _turnManager;

        private readonly CancellationTokenSource _cancellationTokenSource = new();

        // Client-side cache for mod deduplication
        private ClientModCache? _clientCache;
        private ModComponentCache? _componentCache;

        // Thread-safe collections using ConcurrentDictionary for efficient lookups
        private readonly ConcurrentDictionary<string, byte> _recentlySyncedUsers = new();
        private readonly ConcurrentDictionary<string, byte> _blockedUsers = new();
        private readonly ConcurrentDictionary<string, SyncshellInfo> _playerSyncshellAssociations = new();
        private readonly ConcurrentDictionary<string, DateTime> _playerLastSeen = new();
        private readonly ConcurrentDictionary<string, LoadingState> _loadingStates = new();
        
        // Manual upload system (user-initiated)
        private bool _hasPerformedInitialUpload = false;
        
        // Retry systems
        private DateTime _lastReconnectionAttempt = DateTime.MinValue;
        private readonly TimeSpan _reconnectionInterval = TimeSpan.FromMinutes(2);
        private DateTime _lastDiscoveryAttempt = DateTime.MinValue;
        private readonly TimeSpan _discoveryInterval = TimeSpan.FromMinutes(1);
        
        // Public accessors for UI
        public bool HasPerformedInitialUpload => _hasPerformedInitialUpload;
        public ClientModCache? ClientCache => _clientCache;
        public ModComponentCache? ComponentCache => _componentCache;

        // IPC
        private readonly ICallGateSubscriber<bool>? _penumbraEnabled;
        private readonly ICallGateSubscriber<string, Guid>? _penumbraCreateCollection;
        private readonly ICallGateSubscriber<Guid, int, bool>? _penumbraAssignCollection;
        private readonly ICallGateSubscriber<string, object>? _penumbraModSettingChanged;
        private readonly ICallGateSubscriber<object>? _glamourerStateChanged;
        private readonly ICallGateSubscriber<object>? _customizePlusProfileChanged;
        private readonly ICallGateSubscriber<object>? _heelsOffsetChanged;
        private readonly ICallGateSubscriber<object>? _honorificChanged;
        // Mod system status flags (exposed to UI)
        public bool IsPenumbraAvailable => _modSystemIntegration?.IsPenumbraAvailable ?? false;
        public bool IsGlamourerAvailable => _modSystemIntegration?.IsGlamourerAvailable ?? false;
        public bool IsCustomizePlusAvailable => _modSystemIntegration?.IsCustomizePlusAvailable ?? false;
        public bool IsHeelsAvailable => _modSystemIntegration?.IsHeelsAvailable ?? false;
        public bool IsHonorificAvailable => _modSystemIntegration?.IsHonorificAvailable ?? false;

        public FyteClubPlugin(
            IDalamudPluginInterface pluginInterface,
            ICommandManager commandManager,
            IObjectTable objectTable,
            IClientState clientState,
            IPluginLog pluginLog,
            IFramework framework)
        {
            _pluginInterface = pluginInterface;
            _commandManager = commandManager;
            _objectTable = objectTable;
            _clientState = clientState;
            _framework = framework;
            _pluginLog = pluginLog;

            // Initialize SecureLogger
            SecureLogger.Initialize(pluginLog);

            // Initialize WebRTC factory
            LibWebRTCConnection.PluginDirectory = pluginInterface.AssemblyLocation.Directory?.FullName;
            WebRTCConnectionFactory.Initialize(pluginLog);
            // Provide local player name resolver to RobustWebRTCConnection via factory
            WebRTCConnectionFactory.SetLocalPlayerNameResolver(async () => _clientState.LocalPlayer?.Name?.TextValue ?? "");

            // Initialize services
            _modSystemIntegration = new FyteClubModIntegration(pluginInterface, pluginLog, objectTable, framework, clientState);
            _safeModIntegration = new SafeModIntegration(pluginInterface, pluginLog);
            _redrawCoordinator = new FyteClubRedrawCoordinator(pluginLog, _mediator, _modSystemIntegration);
            _playerDetection = new PlayerDetectionService(objectTable, _mediator, _pluginLog);
            _syncshellManager = new SyncshellManager(pluginLog);
            _turnManager = new FyteClub.TURN.TurnServerManager(pluginLog);
            
            // Initialize sync queue processor (runs every 3 seconds)
            _syncQueueProcessor = new Timer(_ => _ = Task.Run(ProcessSyncQueue), null, 
                TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(3));
            
            // Initialize orchestrator after cache initialization
            var networkLogger = new P2PNetworkLogger(pluginLog);
            PhonebookModStateManager? stateManager = null; // Will be set after cache init
            var modApplication = new EnhancedModApplicationService(pluginLog, _modSystemIntegration);

            _windowSystem = new WindowSystem("FyteClub");
            _configWindow = new ConfigWindow(this);
            _windowSystem.AddWindow(_configWindow);

            _commandManager.AddHandler(CommandName, new CommandInfo(OnCommand)
            {
                HelpMessage = "Open FyteClub configuration"
            });

            _pluginInterface.UiBuilder.Draw += _windowSystem.Draw;
            _pluginInterface.UiBuilder.OpenConfigUi += () => _configWindow.Toggle();
            _framework.Update += OnFrameworkUpdate;

            // Subscribe to mediator messages
            _mediator.Subscribe<PlayerDetectedMessage>(this, OnPlayerDetected);
            _mediator.Subscribe<PlayerRemovedMessage>(this, OnPlayerRemoved);
            


            // Initialize IPC
            _penumbraEnabled = _pluginInterface.GetIpcSubscriber<bool>("Penumbra.GetEnabledState");
            _penumbraCreateCollection = _pluginInterface.GetIpcSubscriber<string, Guid>("Penumbra.CreateNamedTemporaryCollection");
            _penumbraAssignCollection = _pluginInterface.GetIpcSubscriber<Guid, int, bool>("Penumbra.AssignTemporaryCollection");
            _penumbraModSettingChanged = _pluginInterface.GetIpcSubscriber<string, object>("Penumbra.ModSettingChanged");
            _glamourerStateChanged = _pluginInterface.GetIpcSubscriber<object>("Glamourer.StateChanged");
            _customizePlusProfileChanged = _pluginInterface.GetIpcSubscriber<object>("CustomizePlus.ProfileChanged");
            _heelsOffsetChanged = _pluginInterface.GetIpcSubscriber<object>("SimpleHeels.OffsetChanged");
            _honorificChanged = _pluginInterface.GetIpcSubscriber<object>("Honorific.TitleChanged");
            
            // Subscribe to all mod system changes for automatic appearance updates
            try
            {
                    _penumbraModSettingChanged?.Subscribe((string _) => OnModSystemChanged());
                    _glamourerStateChanged?.Subscribe(() => OnModSystemChanged());
                    _customizePlusProfileChanged?.Subscribe(() => OnModSystemChanged());
                    _heelsOffsetChanged?.Subscribe(() => OnModSystemChanged());
                    _honorificChanged?.Subscribe(() => OnModSystemChanged());
            }
            catch (Exception ex)
            {
                _pluginLog.Warning($"Failed to subscribe to mod system changes: {ex.Message}");
            }
            
            CheckModSystemAvailability();
            LoadConfiguration();
            InitializeClientCache();
            InitializeComponentCache();
            
            // Initialize orchestrator after caches are ready
            stateManager = new PhonebookModStateManager(pluginLog, _componentCache!, _clientCache!);
            _modSyncOrchestrator = new P2PModSyncOrchestrator(
                pluginLog, networkLogger, stateManager, 
                _componentCache!, _clientCache!, modApplication);
            

            
            ModularLogger.LogAlways(LogModule.Core, "FyteClub v4.5.9 initialized - P2P mod sharing with distributed TURN servers");
        }

        private void InitializeClientCache()
        {
            try
            {
                _clientCache = new ClientModCache(_pluginLog, _pluginInterface.ConfigDirectory.FullName);
                ModularLogger.LogAlways(LogModule.Cache, "Client cache initialized successfully");
            }
            catch (Exception ex)
            {
                ModularLogger.LogAlways(LogModule.Cache, "CRITICAL: Failed to initialize client cache: {0}", ex.Message);
                ModularLogger.LogAlways(LogModule.Cache, "FyteClub will continue with reduced functionality");
            }
        }

        private void InitializeComponentCache()
        {
            try
            {
                _componentCache = new ModComponentCache(_pluginLog, _pluginInterface.ConfigDirectory.FullName);
                ModularLogger.LogAlways(LogModule.Cache, "Component-based mod cache initialized successfully");
            }
            catch (Exception ex)
            {
                ModularLogger.LogAlways(LogModule.Cache, "CRITICAL: Failed to initialize component cache: {0}", ex.Message);
                ModularLogger.LogAlways(LogModule.Cache, "FyteClub will continue with reduced functionality");
            }
        }

        private void CheckModSystemAvailability()
        {
            // Use ModIntegration's robust detection logic
            _modSystemIntegration.RetryDetection();
        }

        private string? _lastLocalPlayerName = null;
        
        private void OnFrameworkUpdate(IFramework framework)
        {
            try
            {
                var localPlayer = _clientState.LocalPlayer;
                var localPlayerName = localPlayer?.Name?.TextValue;
                var isLocalPlayerValid = localPlayer != null && !string.IsNullOrEmpty(localPlayerName);
                
                // Update local player name for self-filtering only if it changed
                if (isLocalPlayerValid && localPlayerName != _lastLocalPlayerName)
                {
                    _syncshellManager.SetLocalPlayerName(localPlayerName!);
                    _lastLocalPlayerName = localPlayerName;
                    ModularLogger.LogDebug(LogModule.Core, "Updated local player name for mod filtering: {0}", localPlayerName);
                }
                
                _mediator.ProcessQueue();
                _playerDetection.ScanForPlayers();
                
                // Bulk apply cached mods for all visible players (every 5 seconds)
                if (ShouldBulkApplyCachedMods())
                {
                    _ = Task.Run(BulkApplyCachedMods);
                }
                
                // Poll phonebook for updates (targeted, not wasteful)
                if (ShouldPollPhonebook())
                {
                    PollPhonebookUpdates();
                }
                
                if (ShouldRetryPeerConnections())
                {
                    _ = Task.Run(AttemptPeerReconnections);
                    _lastReconnectionAttempt = DateTime.UtcNow;
                }
                
                if (ShouldPerformDiscovery())
                {
                    _ = Task.Run(PerformPeerDiscovery);
                    _lastDiscoveryAttempt = DateTime.UtcNow;
                }
                
                // Periodically retry mod system detection if not all are available
                if (!IsPenumbraAvailable || !IsGlamourerAvailable || !IsHonorificAvailable)
                {
                    _modSystemIntegration.RetryDetection();
                }
            }
            catch (Exception ex)
            {
                ModularLogger.LogAlways(LogModule.Core, "Framework error: {0}", ex.Message);
            }
        }
        
        private DateTime _lastBulkCacheApply = DateTime.MinValue;
        private readonly TimeSpan _bulkCacheInterval = TimeSpan.FromSeconds(5);
        
        private bool ShouldBulkApplyCachedMods()
        {
            return (DateTime.UtcNow - _lastBulkCacheApply) >= _bulkCacheInterval;
        }
        
        private async Task BulkApplyCachedMods()
        {
            _lastBulkCacheApply = DateTime.UtcNow;
            
            try
            {
                var allVisiblePlayers = new List<string>();
                
                // Get all visible players from object table
                await _framework.RunOnTick(() =>
                {
                    foreach (var obj in _objectTable)
                    {
                        if (obj?.ObjectKind == Dalamud.Game.ClientState.Objects.Enums.ObjectKind.Player && 
                            obj is Dalamud.Game.ClientState.Objects.SubKinds.IPlayerCharacter player)
                        {
                            var playerName = obj.Name?.ToString();
                            if (!string.IsNullOrEmpty(playerName))
                            {
                                var worldName = player.HomeWorld.IsValid ? player.HomeWorld.Value.Name.ToString() : "Unknown";
                                var playerId = $"{playerName}@{worldName ?? "Unknown"}";
                                allVisiblePlayers.Add(playerId);
                            }
                        }
                    }
                });
                
                if (allVisiblePlayers.Count == 0) return;
                
                var cacheHits = 0;
                var tasks = allVisiblePlayers.Select(async playerName =>
                {
                    // Skip if already processed or blocked
                    if (_blockedUsers.ContainsKey(playerName) || 
                        (_loadingStates.TryGetValue(playerName, out var state) && state == LoadingState.Complete))
                    {
                        return;
                    }
                    
                    // Try to apply cached mods
                    if (await TryApplyCachedModsSilently(playerName))
                    {
                        Interlocked.Increment(ref cacheHits);
                    }
                });
                
                await Task.WhenAll(tasks);
                
                if (cacheHits > 0)
                {
                    ModularLogger.LogDebug(LogModule.Cache, "⚡ BULK: Applied cached mods to {0}/{1} visible players", cacheHits, allVisiblePlayers.Count);
                }
            }
            catch (Exception ex)
            {
                ModularLogger.LogAlways(LogModule.Cache, "Bulk cache apply failed: {0}", ex.Message);
            }
        }
        
        private async Task<bool> TryApplyCachedModsSilently(string playerName)
        {
            try
            {
                // Check component cache first
                if (_componentCache != null)
                {
                    var cachedRecipe = await _componentCache.GetCachedAppearanceRecipe(playerName);
                    if (cachedRecipe != null)
                    {
                        await _modSystemIntegration.ApplyPlayerMods(cachedRecipe, playerName);
                        _loadingStates[playerName] = LoadingState.Complete;
                        return true;
                    }
                }
                
                // Check client cache
                if (_clientCache != null)
                {
                    var cachedMods = await _clientCache.GetCachedPlayerMods(playerName);
                    if (cachedMods != null)
                    {
                        await ApplyPlayerModsFromCache(playerName, cachedMods);
                        _loadingStates[playerName] = LoadingState.Complete;
                        return true;
                    }
                }
                
                return false;
            }
            catch
            {
                return false;
            }
        }

        private bool ShouldRetryPeerConnections()
        {
            if ((DateTime.UtcNow - _lastReconnectionAttempt) < _reconnectionInterval) return false;
            return _syncshellManager.GetSyncshells().Any(s => s.IsActive);
        }

        private bool ShouldPerformDiscovery()
        {
            if ((DateTime.UtcNow - _lastDiscoveryAttempt) < _discoveryInterval) return false;
            return _syncshellManager.GetSyncshells().Any(s => s.IsActive);
        }

        private DateTime _lastPhonebookPoll = DateTime.MinValue;
        private readonly TimeSpan _phonebookPollInterval = TimeSpan.FromSeconds(10);
        
        private bool ShouldPollPhonebook()
        {
            if ((DateTime.UtcNow - _lastPhonebookPoll) < _phonebookPollInterval) return false;
            return _syncshellManager.GetSyncshells().Any(s => s.IsActive);
        }

        private void PollPhonebookUpdates()
        {
            _lastPhonebookPoll = DateTime.UtcNow;
            
            _framework.RunOnFrameworkThread(() =>
            {
                try
                {
                    var nearbyPlayers = new List<PlayerSnapshot>();
                    foreach (var obj in _objectTable)
                    {
                        if (obj?.ObjectKind == Dalamud.Game.ClientState.Objects.Enums.ObjectKind.Player && 
                            obj.Name?.TextValue != _clientState.LocalPlayer?.Name?.TextValue &&
                            !string.IsNullOrEmpty(obj.Name?.TextValue))
                        {
                            nearbyPlayers.Add(new PlayerSnapshot
                            {
                                Name = obj.Name.TextValue,
                                ObjectIndex = obj.ObjectIndex
                            });
                        }
                    }
                    // Only check players we can see for phonebook updates
                    CheckPlayersForChanges(nearbyPlayers);
                }
                catch (Exception ex)
                {
                    _pluginLog.Warning($"Phonebook polling failed: {ex.Message}");
                }
            });
        }

        private async Task AttemptPeerReconnections()
        {
            // Reconnect to active syncshells using Nostr signaling (not old manual codes)
            var activeSyncshells = _syncshellManager.GetSyncshells().Where(s => s.IsActive).ToList();
            if (activeSyncshells.Count == 0) return;
            
            ModularLogger.LogDebug(LogModule.WebRTC, "Attempting peer reconnections for {0} active syncshells...", activeSyncshells.Count);
            
            foreach (var syncshell in activeSyncshells)
            {
                try
                {
                    // Initialize syncshell as host to accept new Nostr connections
                    if (syncshell.IsOwner)
                    {
                        await _syncshellManager.InitializeAsHost(syncshell.Id);
                        ModularLogger.LogDebug(LogModule.Syncshells, "Reinitialized host for syncshell: {0}", syncshell.Name);
                    }
                    else
                    {
                        // For joined syncshells, request member list sync to discover active peers
                        await _syncshellManager.RequestMemberListSync(syncshell.Id);
                        ModularLogger.LogDebug(LogModule.Syncshells, "Requested member sync for syncshell: {0}", syncshell.Name);
                    }
                }
                catch (Exception ex)
                {
                    ModularLogger.LogAlways(LogModule.Syncshells, "Failed to reconnect to syncshell {0}: {1}", syncshell.Name, ex.Message);
                }
            }
        }

        private async Task PerformPeerDiscovery()
        {
            var activeSyncshells = _syncshellManager.GetSyncshells().Where(s => s.IsActive).ToList();
            if (activeSyncshells.Count == 0) return;
            
            // Test WebRTC availability with crash protection
            try
            {
                await Task.Run(async () => {
                    try
                    {
                        var testConnection = await WebRTCConnectionFactory.CreateConnectionAsync(_turnManager);
                        testConnection?.Dispose();
                        
                        ModularLogger.LogDebug(LogModule.WebRTC, "WebRTC P2P ready for {0} active syncshells", activeSyncshells.Count);
                        foreach (var syncshell in activeSyncshells)
                        {
                            ModularLogger.LogDebug(LogModule.Syncshells, "  - '{0}' ID: {1} (Use invite codes to connect)", syncshell.Name, syncshell.Id);
                        }
                    }
                    catch (Exception innerEx)
                    {
                        ModularLogger.LogAlways(LogModule.WebRTC, "WebRTC initialization failed - {0}", innerEx.Message);
                        ModularLogger.LogAlways(LogModule.WebRTC, "{0} syncshells configured but P2P connections disabled", activeSyncshells.Count);
                    }
                });
            }
            catch (Exception ex)
            {
                ModularLogger.LogAlways(LogModule.WebRTC, "WebRTC test task failed - {0}", ex.Message);
                ModularLogger.LogAlways(LogModule.WebRTC, "P2P connections disabled due to WebRTC issues");
            }
        }
        


        private readonly PriorityQueue<SyncQueueEntry, float> _syncQueue = new();
        private readonly Dictionary<string, string> _playerHashes = new();
        private readonly SemaphoreSlim _syncProcessingSemaphore = new(1, 1);
        private readonly Timer _syncQueueProcessor;
        private const int BATCH_SIZE = 5;
        private bool _isProcessingQueue = false;
        
        private void OnPlayerDetected(PlayerDetectedMessage message)
        {
            if (_blockedUsers.ContainsKey(message.PlayerName))
            {
                return;
            }

            // INSTANT: Apply cached mods for ALL visible players (no distance limit)
            _ = Task.Run(async () => await TryApplyCachedModsInstantly(message.PlayerName));
            
            // QUEUED: Add uncached players to distance-based P2P sync queue
            _ = Task.Run(() => AddToSyncQueueIfNeeded(message));
        }
        
        private async Task TryApplyCachedModsInstantly(string playerName)
        {
            try
            {
                bool cacheHit = false;
                
                // Check component cache first (fastest)
                if (_componentCache != null)
                {
                    var cachedRecipe = await _componentCache.GetCachedAppearanceRecipe(playerName);
                    if (cachedRecipe != null)
                    {
                        ModularLogger.LogDebug(LogModule.Cache, "⚡ INSTANT: Cached recipe applied for {0}", playerName);
                        await _modSystemIntegration.ApplyPlayerMods(cachedRecipe, playerName);
                        _loadingStates[playerName] = LoadingState.Complete;
                        cacheHit = true;
                    }
                }
                
                // Check client cache if no component cache hit
                if (!cacheHit && _clientCache != null)
                {
                    var cachedMods = await _clientCache.GetCachedPlayerMods(playerName);
                    if (cachedMods?.RecipeData != null)
                    {
                        ModularLogger.LogDebug(LogModule.Cache, "⚡ INSTANT: Cached mods applied for {0}", playerName);
                        await ApplyPlayerModsFromCache(playerName, cachedMods);
                        _loadingStates[playerName] = LoadingState.Complete;
                        cacheHit = true;
                    }
                }
                
                if (!cacheHit)
                {
                    ModularLogger.LogDebug(LogModule.ModSync, "No cache for {0} - will queue for P2P sync", playerName);
                }
            }
            catch (Exception ex)
            {
                ModularLogger.LogAlways(LogModule.Cache, "Failed to apply cached mods for {0}: {1}", playerName, ex.Message);
            }
        }
        
        private void AddToSyncQueueIfNeeded(PlayerDetectedMessage message)
        {
            // Only queue for P2P sync if not already processed by cache
            if (_loadingStates.TryGetValue(message.PlayerName, out var state) && 
                state == LoadingState.Complete)
            {
                return; // Already handled by cache
            }
            
            _framework.RunOnFrameworkThread(() =>
            {
                var localPlayer = _clientState.LocalPlayer;
                if (localPlayer == null) return;
                
                var msgPos = new System.Numerics.Vector3(message.Position.X, message.Position.Y, message.Position.Z);
                var distance = System.Numerics.Vector3.Distance(localPlayer.Position, msgPos);
                var entry = new SyncQueueEntry
                {
                    PlayerName = message.PlayerName,
                    Position = message.Position,
                    DetectedAt = DateTime.UtcNow,
                    Priority = distance
                };
                
                lock (_syncQueue)
                {
                    _syncQueue.Enqueue(entry, distance);
                }
                
                ModularLogger.LogDebug(LogModule.ModSync, "Queued {0} for P2P sync at {1:F1}m", message.PlayerName, distance);
            });
        }
        

        
        private async Task ProcessSyncQueue()
        {
            if (_isProcessingQueue || !await _syncProcessingSemaphore.WaitAsync(100)) return;
            
            _isProcessingQueue = true;
            try
            {
                var batch = new List<SyncQueueEntry>();
                
                // Dequeue up to BATCH_SIZE entries (already sorted by priority)
                lock (_syncQueue)
                {
                    while (_syncQueue.Count > 0 && batch.Count < BATCH_SIZE)
                    {
                        batch.Add(_syncQueue.Dequeue());
                    }
                }
                
                if (batch.Count == 0) return;
                
                ModularLogger.LogDebug(LogModule.ModSync, "Processing sync batch: {0} players", batch.Count);
                
                // Process batch in parallel
                var tasks = batch.Select(async entry =>
                {
                    try
                    {
                        await ProcessPlayerSync(entry);
                    }
                    catch (Exception ex)
                    {
                        ModularLogger.LogAlways(LogModule.ModSync, "Failed to sync {0}: {1}", entry.PlayerName, ex.Message);
                    }
                });
                
                await Task.WhenAll(tasks);
                
                // Check for hash changes and re-queue if needed
                await CheckForHashChanges();
            }
            finally
            {
                _isProcessingQueue = false;
                _syncProcessingSemaphore.Release();
            }
        }
        
        private async Task ProcessPlayerSync(SyncQueueEntry entry)
        {
            // Skip if already processed by cache or currently processing
            if (_loadingStates.TryGetValue(entry.PlayerName, out var state) && 
                (state == LoadingState.Complete || state == LoadingState.Requesting))
            {
                return;
            }
            
            _loadingStates[entry.PlayerName] = LoadingState.Requesting;
            ModularLogger.LogDebug(LogModule.ModSync, "🔄 P2P Sync: {0} (queued {1:F1}s ago)", entry.PlayerName, (DateTime.UtcNow - entry.DetectedAt).TotalSeconds);
            
            // Establish P2P connection and sync new data
            await TryEstablishP2PConnection(entry.PlayerName);
            await RequestPlayerModsSafely(entry.PlayerName);
            
            // Update hash after sync
            var currentHash = await GetPlayerModHash(entry.PlayerName);
            if (!string.IsNullOrEmpty(currentHash))
            {
                _playerHashes[entry.PlayerName] = currentHash;
            }
        }
        
        private async Task CheckForHashChanges()
        {
            try
            {
                // Get phonebook updates from all active syncshells
                var activeSyncshells = _syncshellManager.GetSyncshells().Where(s => s.IsActive);
                
                foreach (var syncshell in activeSyncshells)
                {
                    // Request phonebook update to get latest hashes
                    await _syncshellManager.RequestPhonebookUpdate(syncshell.Id);
                }
                
                // Check for players with changed hashes
                var playersToRequeue = new List<string>();
                
                foreach (var kvp in _playerHashes.ToList())
                {
                    var playerName = kvp.Key;
                    var oldHash = kvp.Value;
                    var currentHash = await GetPlayerModHash(playerName);
                    
                    if (!string.IsNullOrEmpty(currentHash) && currentHash != oldHash)
                    {
                        playersToRequeue.Add(playerName);
                        ModularLogger.LogDebug(LogModule.ModSync, "Hash changed for {0}: {1} -> {2}", playerName, oldHash[..8], currentHash[..8]);
                    }
                }
                
                // Re-queue players with changed hashes (high priority)
                foreach (var playerName in playersToRequeue)
                {
                    var entry = new SyncQueueEntry
                    {
                        PlayerName = playerName,
                        DetectedAt = DateTime.UtcNow,
                        Priority = 0.1f // High priority for hash changes
                    };
                    
                    lock (_syncQueue)
                    {
                        _syncQueue.Enqueue(entry, 0.1f);
                    }
                }
            }
            catch (Exception ex)
            {
                ModularLogger.LogAlways(LogModule.ModSync, "Hash change check failed: {0}", ex.Message);
            }
        }
        
        private async Task<string> GetPlayerModHash(string playerName)
        {
            try
            {
                var modData = _syncshellManager.GetPlayerModData(playerName);
                if (modData?.ComponentData != null)
                {
                    // Calculate hash from mod data
                    var json = System.Text.Json.JsonSerializer.Serialize(modData.ComponentData);
                    using var sha256 = System.Security.Cryptography.SHA256.Create();
                    var hashBytes = sha256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(json));
                    return Convert.ToHexString(hashBytes)[..16];
                }
                return string.Empty;
            }
            catch
            {
                return string.Empty;
            }
        }
        
        private async Task TryEstablishP2PConnection(string playerName)
        {
            var activeSyncshells = _syncshellManager.GetSyncshells().Where(s => s.IsActive);
            var isKnownMember = activeSyncshells.Any(s => s.Members?.Contains(playerName) == true);
            
            if (isKnownMember)
            {
                await TryEstablishP2PConnectionToKnownPlayer(playerName);
            }
            else
            {
                var phonebookEntry = _syncshellManager.GetPhonebookEntry(playerName);
                if (phonebookEntry != null)
                {
                    await TryEstablishP2PConnectionToKnownPlayer(playerName);
                }
                else if (activeSyncshells.Any())
                {
                    await TryDiscoverPlayerSyncshells(playerName);
                }
            }
        }

        private void OnPlayerRemoved(PlayerRemovedMessage message)
        {
            _loadingStates.TryRemove(message.PlayerName, out _);
        }
        
        private async Task TryEstablishP2PConnectionToKnownPlayer(string playerName)
        {
            try
            {
                var activeSyncshells = _syncshellManager.GetSyncshells().Where(s => s.IsActive);
                foreach (var syncshell in activeSyncshells)
                {
                    // Check if player is a member of this syncshell
                    if (syncshell.Members?.Contains(playerName) == true)
                    {
                        _pluginLog.Info($"FyteClub: Attempting P2P connection to known member {playerName} in syncshell '{syncshell.Name}'");
                        
                        var success = await _syncshellManager.ConnectToPeer(syncshell.Id, playerName, "");
                        if (success)
                        {
                            _pluginLog.Info($"FyteClub: P2P connection established with known member {playerName}");
                            
                            // Add to phonebook after successful connection
                            _syncshellManager.AddToPhonebook(playerName, syncshell.Id);
                            return;
                        }
                        else
                        {
                            _pluginLog.Warning($"FyteClub: Failed to connect to known member {playerName}");
                        }
                    }
                }
                
                _pluginLog.Info($"FyteClub: Player {playerName} not found in any active syncshell member lists");
            }
            catch (Exception ex)
            {
                _pluginLog.Warning($"FyteClub: Failed to establish P2P connection with known player {playerName}: {ex.Message}");
            }
        }
        
        private async Task TryDiscoverPlayerSyncshells(string playerName)
        {
            try
            {
                var activeSyncshells = _syncshellManager.GetSyncshells().Where(s => s.IsActive);
                foreach (var syncshell in activeSyncshells)
                {
                    _pluginLog.Info($"FyteClub: Attempting syncshell discovery with {playerName} for '{syncshell.Name}'");
                    
                    // Try to establish P2P connection to discover if they're in this syncshell
                    var success = await _syncshellManager.ConnectToPeer(syncshell.Id, playerName, "");
                    if (success)
                    {
                        _pluginLog.Info($"FyteClub: Discovered {playerName} is in syncshell '{syncshell.Name}'");
                        // Only add to phonebook, not member list (member list updated via P2P messages)
                        _syncshellManager.AddToPhonebook(playerName, syncshell.Id);
                        return;
                    }
                }
                
                _pluginLog.Debug($"FyteClub: Player {playerName} not found in any active syncshells");
            }
            catch (Exception ex)
            {
                _pluginLog.Warning($"FyteClub: Failed to discover syncshells for {playerName}: {ex.Message}");
            }
        }
        


        // Safe mod request with rate limiting and reduced logging
        private async Task RequestPlayerModsSafely(string playerName)
        {
            try
            {
                if (_clientCache != null)
                {
                    var cachedMods = await _clientCache.GetCachedPlayerMods(playerName);
                    if (cachedMods != null)
                    {
                        _pluginLog.Debug($"Cache hit for {playerName}");
                        return;
                    }
                }
                
                var activeSyncshells = _syncshellManager.GetSyncshells().Where(s => s.IsActive);
                foreach (var syncshell in activeSyncshells)
                {
                    var success = await RequestPlayerModsFromSyncshellSafely(playerName, syncshell);
                    if (success)
                    {
                        _playerSyncshellAssociations[playerName] = syncshell;
                        _playerLastSeen[playerName] = DateTime.UtcNow;
                        break;
                    }
                }
            }
            catch (Exception ex)
            {
                _pluginLog.Warning($"Safe mod request failed for {playerName}: {ex.Message}");
                _loadingStates[playerName] = LoadingState.Failed;
            }
        }
        
        private async Task<bool> RequestPlayerModsFromSyncshellSafely(string playerName, SyncshellInfo syncshell)
        {
            try
            {
                // For P2P proximity-based connections, we try to sync with any nearby player
                // who might be in our syncshells. The P2P connection will verify membership.
                _pluginLog.Debug($"Player {playerName} detected nearby - checking for P2P sync opportunity");
                
                _loadingStates[playerName] = LoadingState.Downloading;
                
                // Check if we have mod data from P2P connection
                var modData = _syncshellManager.GetPlayerModData(playerName);
                if (modData != null)
                {
                    // Store in deduped cache system
                    if (_clientCache != null && modData.RecipeData != null)
                    {
                        _clientCache.UpdateRecipeForPlayer(playerName, modData.RecipeData);
                    }
                    if (_componentCache != null && modData.ComponentData != null)
                    {
                        _componentCache.UpdateComponentForPlayer(playerName, modData.ComponentData);
                    }
                    
                    // Apply mods using full integration system
                    var reconstructedPlayerInfo = new AdvancedPlayerInfo
                    {
                        PlayerName = playerName,
                        Mods = (modData.ComponentData as List<string>) ?? new List<string>(),
                        GlamourerDesign = modData.RecipeData?.ToString()
                    };
                    
                    var success = await _modSystemIntegration.ApplyPlayerMods(reconstructedPlayerInfo, playerName);
                    if (success)
                    {
                        _pluginLog.Debug($"Applied P2P mods for {playerName} from syncshell {syncshell.Name}");
                        _loadingStates[playerName] = LoadingState.Complete;
                        _playerLastSeen[playerName] = DateTime.UtcNow;
                        _recentlySyncedUsers.TryAdd(playerName, 0);
                        return true;
                    }
                }
                
                // Apply cached mods using full integration
                if (_recentlySyncedUsers.ContainsKey(playerName))
                {
                    var cachedMods = await _clientCache?.GetCachedPlayerMods(playerName);
                    if (cachedMods?.RecipeData != null)
                    {
                        var playerInfo = cachedMods.RecipeData as AdvancedPlayerInfo;
                        if (playerInfo != null)
                        {
                            var success = await _modSystemIntegration.ApplyPlayerMods(playerInfo, playerName);
                            if (success)
                            {
                                _pluginLog.Debug($"Applied cached mods for {playerName} from syncshell {syncshell.Name}");
                                _loadingStates[playerName] = LoadingState.Complete;
                                _playerLastSeen[playerName] = DateTime.UtcNow;
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            catch (Exception ex)
            {
                _pluginLog.Warning($"Safe syncshell request failed: {ex.Message}");
                return false;
            }
        }



        public async Task<SyncshellInfo> CreateSyncshell(string name)
        {
            _pluginLog.Info($"[DEBUG] FyteClubPlugin.CreateSyncshell START - name: '{name}'");
            Console.WriteLine($"[DEBUG] FyteClubPlugin.CreateSyncshell START - name: '{name}'");
            
            try
            {
                _pluginLog.Info($"[DEBUG] Calling _syncshellManager.CreateSyncshell");
                var syncshell = await _syncshellManager.CreateSyncshell(name);
                _pluginLog.Info($"[DEBUG] _syncshellManager.CreateSyncshell returned: {syncshell?.Name ?? "null"}");
                
                syncshell.IsActive = true;
                _pluginLog.Info($"[DEBUG] Set syncshell.IsActive = true");
                
                SaveConfiguration();
                _pluginLog.Info($"[DEBUG] SaveConfiguration() called");
                
                // Wire up P2P message handling BEFORE initializing as host
                _pluginLog.Info($"[DEBUG] About to wire up P2P message handling for syncshell {syncshell.Id}");
                
                // Must run on framework thread to access LocalPlayer
                await _framework.RunOnFrameworkThread(() => {
                    WireUpP2PMessageHandling(syncshell.Id);
                });
                
                _pluginLog.Info($"[DEBUG] P2P message handling wired up for syncshell {syncshell.Id}");
                
                // Initialize the syncshell as ready to accept P2P connections
                await _syncshellManager.InitializeAsHost(syncshell.Id);
                
                // CRITICAL: Collect and cache host's own mod data immediately
                await _framework.RunOnFrameworkThread(async () => {
                    var localPlayer = _clientState.LocalPlayer;
                    var localPlayerName = localPlayer?.Name?.TextValue;
                    if (!string.IsNullOrEmpty(localPlayerName))
                    {
                        _pluginLog.Info($"🎯 [HOST] Collecting own mod data for: {localPlayerName}");
                        await SharePlayerModsToSyncshells(localPlayerName);
                        _pluginLog.Info($"🎯 [HOST] Host mod data collected and cached");
                    }
                    else
                    {
                        _pluginLog.Warning($"🎯 [HOST] Could not get local player name for mod collection");
                    }
                });
                
                _pluginLog.Info($"[DEBUG] FyteClubPlugin.CreateSyncshell SUCCESS - returning syncshell");
                return syncshell;
            }
            catch (Exception ex)
            {
                _pluginLog.Error($"[DEBUG] FyteClubPlugin.CreateSyncshell EXCEPTION: {ex.Message}");
                _pluginLog.Error($"[DEBUG] Stack trace: {ex.StackTrace}");
                Console.WriteLine($"[DEBUG] FyteClubPlugin.CreateSyncshell EXCEPTION: {ex.Message}");
                throw;
            }
        }

        public bool JoinSyncshell(string syncshellName, string encryptionKey)
        {
            _pluginLog.Info($"[DEBUG] FyteClubPlugin.JoinSyncshell START - name: '{syncshellName}'");
            Console.WriteLine($"[DEBUG] FyteClubPlugin.JoinSyncshell START - name: '{syncshellName}'");
            
            try
            {
                _pluginLog.Info($"[DEBUG] Calling _syncshellManager.JoinSyncshell");
                var joinResult = _syncshellManager.JoinSyncshell(syncshellName, encryptionKey);
                _pluginLog.Info($"[DEBUG] _syncshellManager.JoinSyncshell returned: {joinResult}");
                
                if (joinResult) 
                {
                    _pluginLog.Info($"[DEBUG] Join successful, saving configuration");
                    SaveConfiguration();
                    _pluginLog.Info($"[DEBUG] Configuration saved");
                    
                    // Note: Auto-sharing will happen after P2P connection is established
                    // via EstablishInitialP2P Connection method
                }
                else
                {
                    _pluginLog.Warning($"[DEBUG] Join failed");
                }
                
                _pluginLog.Info($"[DEBUG] FyteClubPlugin.JoinSyncshell returning: {joinResult}");
                return joinResult;
            }
            catch (Exception ex)
            {
                _pluginLog.Error($"[DEBUG] FyteClubPlugin.JoinSyncshell EXCEPTION: {ex.Message}");
                _pluginLog.Error($"[DEBUG] Stack trace: {ex.StackTrace}");
                Console.WriteLine($"[DEBUG] FyteClubPlugin.JoinSyncshell EXCEPTION: {ex.Message}");
                return false;
            }
        }

        public void RemoveSyncshell(string syncshellId)
        {
            _syncshellManager.RemoveSyncshell(syncshellId);
            SaveConfiguration();
        }

        public Configuration GetConfiguration()
        {
            return _pluginInterface.GetPluginConfig() as Configuration ?? new Configuration();
        }
        
        public void UpdateTurnServerPort(int newPort)
        {
            var config = GetConfiguration();
            config.TurnServerPort = newPort;
            _pluginInterface.SavePluginConfig(config);
        }
        
        public void SaveConfiguration()
        {
            var existingConfig = GetConfiguration();
            var config = new Configuration 
            { 
                Syncshells = _syncshellManager.GetSyncshells(),
                BlockedUsers = _blockedUsers.Keys.ToList(),
                RecentlySyncedUsers = _recentlySyncedUsers.Keys.ToList(),
                EnableTurnHosting = _turnManager?.IsHostingEnabled ?? false,
                TurnServerPort = existingConfig.TurnServerPort // Preserve configured port, not running port
            };
            _pluginInterface.SavePluginConfig(config);
        }

        public List<SyncshellInfo> GetSyncshells()
        {
            return _syncshellManager.GetSyncshells();
        }

        public void ShareMods()
        {
            _framework.RunOnFrameworkThread(() =>
            {
                var localPlayer = _clientState.LocalPlayer;
                var localPlayerName = localPlayer?.Name?.TextValue;
                if (string.IsNullOrEmpty(localPlayerName)) return;
                
                var capturedPlayerName = localPlayerName;
                _ = Task.Run(async () =>
                {
                    try
                    {
                        await SharePlayerModsToSyncshells(capturedPlayerName);
                        _pluginLog.Info($"FyteClub: Shared mods to syncshell peers");
                    }
                    catch (Exception ex)
                    {
                        _pluginLog.Error($"FyteClub: Failed to share mods: {ex.Message}");
                    }
                });
            });
        }

        public void RequestAllPlayerMods()
        {
            _framework.RunOnFrameworkThread(() =>
            {
                var localPlayer = _clientState.LocalPlayer;
                var localPlayerName = localPlayer?.Name?.TextValue;
                if (string.IsNullOrEmpty(localPlayerName)) return;
                
                var capturedPlayerName = localPlayerName;
                _ = Task.Run(async () =>
                {
                    try
                    {
                        await SharePlayerModsToSyncshells(capturedPlayerName);
                    }
                    catch (Exception ex)
                    {
                        _pluginLog.Error($"FyteClub: Manual mod upload failed: {ex.Message}");
                    }
                });
            });
        }

        public void BlockUser(string playerName)
        {
            if (_blockedUsers.TryAdd(playerName, 0))
            {
                _loadingStates.TryRemove(playerName, out _);
                SaveConfiguration();
            }
        }

        public void UnblockUser(string playerName)
        {
            if (_blockedUsers.TryRemove(playerName, out _))
            {
                SaveConfiguration();
            }
        }

        public bool IsUserBlocked(string playerName)
        {
            return _blockedUsers.ContainsKey(playerName);
        }

        public IEnumerable<string> GetRecentlySyncedUsers()
        {
            return _recentlySyncedUsers.Keys.OrderBy(name => name);
        }

        public void TestBlockUser(string playerName)
        {
            _recentlySyncedUsers.TryAdd(playerName, 0);
        }

        public void ReconnectAllPeers()
        {
            _ = Task.Run(async () =>
            {
                await PerformPeerDiscovery();
                await AttemptPeerReconnections();
            });
        }
        
        public async Task EstablishInitialP2PConnection(string inviteCode)
        {
            try
            {
                _pluginLog.Info("FyteClub: P2P connection already established via JoinSyncshellByInviteCode");
                
                // Extract syncshell name from NOSTR invite code
                string syncshellName = "Unknown";
                if (inviteCode.StartsWith("NOSTR:"))
                {
                    try
                    {
                        var base64 = inviteCode.Substring(6);
                        var json = System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(base64));
                        var invite = JsonSerializer.Deserialize<JsonElement>(json);
                        syncshellName = invite.GetProperty("name").GetString() ?? "Unknown";
                    }
                    catch
                    {
                        _pluginLog.Error("Failed to parse NOSTR invite code for syncshell name");
                        return;
                    }
                }
                else
                {
                    var parts = inviteCode.Split(':', 4);
                    if (parts.Length >= 1) syncshellName = parts[0];
                }
                
                // Find the syncshell we just joined
                var syncshell = _syncshellManager.GetSyncshells().FirstOrDefault(s => s.Name == syncshellName);
                if (syncshell == null)
                {
                    _pluginLog.Error($"Could not find joined syncshell: {syncshellName}");
                    return;
                }
                
                // Capture player name on framework thread before async operations
                string? capturedPlayerName = null;
                string? capturedWorldName = null;
                
                await _framework.RunOnTick(() =>
                {
                    var localPlayer = _clientState.LocalPlayer;
                    capturedPlayerName = localPlayer?.Name?.TextValue;
                    capturedWorldName = localPlayer?.HomeWorld.IsValid == true ? localPlayer.HomeWorld.Value.Name.ToString() : null;
                });
                
                // Member list sync will be handled automatically by the bootstrap logic when WebRTC data channel opens
                _pluginLog.Info($"FyteClub: Member list sync will be handled by bootstrap when WebRTC connection is ready");
                
                // Share our appearance immediately
                if (!string.IsNullOrEmpty(capturedPlayerName))
                {
                    _ = Task.Run(async () => await SharePlayerModsToSyncshells(capturedPlayerName));
                }
            }
            catch (Exception ex)
            {
                _pluginLog.Error($"FyteClub: Error in post-join member sync: {ex.Message}");
            }
        }

        // Remove await warning by making CreateSyncshellInternal synchronous
        private void LoadConfiguration()
        {
            var config = _pluginInterface.GetPluginConfig() as Configuration ?? new Configuration();
            foreach (var syncshell in config.Syncshells ?? new List<SyncshellInfo>())
            {
                if (syncshell.IsOwner)
                {
                    _syncshellManager.CreateSyncshellInternal(syncshell.Name, syncshell.EncryptionKey);
                }
                else
                {
                    _syncshellManager.JoinSyncshellById(syncshell.Id, syncshell.EncryptionKey, syncshell.Name);
                }
                // Auto-activate all loaded syncshells
                var loadedSyncshell = _syncshellManager.GetSyncshells().LastOrDefault();
                if (loadedSyncshell != null)
                {
                    loadedSyncshell.IsActive = syncshell.IsActive;
                }
            }
            foreach (var blockedUser in config.BlockedUsers ?? new List<string>())
            {
                _blockedUsers.TryAdd(blockedUser, 0);
            }
            foreach (var syncedUser in config.RecentlySyncedUsers ?? new List<string>())
            {
                _recentlySyncedUsers.TryAdd(syncedUser, 0);
            }
            
            // Auto-enable TURN hosting if configured
            if (config.EnableTurnHosting)
            {
                _ = Task.Run(async () => {
                    if (_turnManager != null)
                    {
                        await _turnManager.EnableHostingAsync(config.TurnServerPort);
                        _pluginLog.Info($"[TURN] Auto-enabled hosting on port {config.TurnServerPort} from saved configuration");
                    }
                });
            }
        }





        private async Task SharePlayerModsToSyncshells(string playerName)
        {
            var playerInfo = await _modSystemIntegration.GetCurrentPlayerMods(playerName);
            if (playerInfo != null)
            {
                var outfitHash = CalculateModDataHash(playerInfo);
                
                _pluginLog.Info($"📤 [MOD SHARING] Preparing to share mods for {playerName}:");
                _pluginLog.Info($"📤 [MOD SHARING]   - Mods to share: {playerInfo.Mods?.Count ?? 0}");
                if (playerInfo.Mods?.Count > 0)
                {
                    for (int i = 0; i < Math.Min(5, playerInfo.Mods.Count); i++)
                    {
                        _pluginLog.Info($"📤 [MOD SHARING]     [{i}]: {playerInfo.Mods[i]}");
                    }
                    if (playerInfo.Mods.Count > 5)
                    {
                        _pluginLog.Info($"📤 [MOD SHARING]     ... and {playerInfo.Mods.Count - 5} more");
                    }
                }
                _pluginLog.Info($"📤 [MOD SHARING]   - Glamourer: {(string.IsNullOrEmpty(playerInfo.GlamourerDesign) ? "None" : "Present")}");
                _pluginLog.Info($"📤 [MOD SHARING]   - Hash: {outfitHash?[..8] ?? "none"}");
                
                // CRITICAL: Store host's own mod data in cache for sharing with joiners
                var componentData = new
                {
                    mods = playerInfo.Mods,
                    glamourerDesign = playerInfo.GlamourerDesign,
                    customizePlusProfile = playerInfo.CustomizePlusProfile,
                    simpleHeelsOffset = playerInfo.SimpleHeelsOffset,
                    honorificTitle = playerInfo.HonorificTitle
                };
                
                var modDataDict = new Dictionary<string, object>
                {
                    ["type"] = "mod_data",
                    ["playerId"] = playerName,
                    ["playerName"] = playerName,
                    ["outfitHash"] = outfitHash ?? "",
                    ["mods"] = playerInfo.Mods ?? new List<string>(),
                    ["glamourerDesign"] = playerInfo.GlamourerDesign ?? "",
                    ["customizePlusProfile"] = playerInfo.CustomizePlusProfile ?? "",
                    ["simpleHeelsOffset"] = playerInfo.SimpleHeelsOffset ?? 0.0f,
                    ["honorificTitle"] = playerInfo.HonorificTitle ?? "",
                    ["timestamp"] = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
                };
                
                _syncshellManager.UpdatePlayerModData(playerName, componentData, modDataDict);
                _pluginLog.Info($"📤 [MOD SHARING] Cached own mod data for {playerName} (host)");
                
                var activeSyncshells = _syncshellManager.GetSyncshells().Where(s => s.IsActive);
                foreach (var syncshell in activeSyncshells)
                {
                    try
                    {
                        var modData = new
                        {
                            type = "mod_data",
                            playerId = playerName,
                            playerName = playerName,
                            outfitHash = outfitHash,
                            mods = playerInfo.Mods,
                            glamourerDesign = playerInfo.GlamourerDesign,
                            customizePlusProfile = playerInfo.CustomizePlusProfile,
                            simpleHeelsOffset = playerInfo.SimpleHeelsOffset,
                            honorificTitle = playerInfo.HonorificTitle,
                            timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
                        };

                        var json = JsonSerializer.Serialize(modData);
                        _pluginLog.Info($"📤 [MOD SHARING] Serialized JSON size: {json.Length} characters");
                        _pluginLog.Info($"📤 [MOD SHARING] Sending to syncshell: {syncshell.Name}");
                        
                        await _syncshellManager.SendModData(syncshell.Id, json);
                        
                        _pluginLog.Info($"📤 [MOD SHARING] Successfully sent mod data to {syncshell.Name}");
                    }
                    catch (Exception ex)
                    {
                        _pluginLog.Warning($"📤 [MOD SHARING] Failed to send mods to syncshell {syncshell.Name}: {ex.Message}");
                    }
                }
                
                _hasPerformedInitialUpload = true;
            }
            else
            {
                _pluginLog.Warning($"📤 [MOD SHARING] No player info collected for {playerName} - nothing to share");
            }
        }

        private void OnModSystemChanged()
        {
            // Automatically share appearance when any mod system changes
            _framework.RunOnFrameworkThread(() =>
            {
                var localPlayer = _clientState.LocalPlayer;
                if (localPlayer?.Name?.TextValue != null)
                {
                    var playerName = localPlayer.Name.TextValue;
                    _ = Task.Run(async () =>
                    {
                        await Task.Delay(1000); // Brief delay for changes to apply
                        
                        // Update cache with new mod data
                        var updatedMods = await _modSystemIntegration.GetCurrentPlayerMods(playerName);
                        if (updatedMods != null && _componentCache != null)
                        {
                            var newHash = CalculateModDataHash(updatedMods);
                            await _componentCache.StoreAppearanceRecipe(playerName, newHash, updatedMods);
                        }
                        
                        await SharePlayerModsToSyncshells(playerName);
                        
                        // Share companion mods on main thread
                        _framework.RunOnFrameworkThread(() => ShareCompanionMods(playerName));
                        
                        _pluginLog.Debug($"Auto-shared appearance and companion mods after change");
                    });
                }
            });
        }

        private void ShareCompanionMods(string ownerName)
        {
            try
            {
                // Find companions owned by this player
                var companions = new List<CompanionSnapshot>();
                foreach (var obj in _objectTable)
                {
                    if (obj is IBattleNpc npc && npc.OwnerId == _clientState.LocalPlayer?.GameObjectId)
                    {
                        companions.Add(new CompanionSnapshot
                        {
                            Name = $"{ownerName}'s {npc.Name}",
                            ObjectKind = npc.ObjectKind.ToString(),
                            ObjectIndex = obj.ObjectIndex
                        });
                    }
                }

                if (companions.Count > 0)
                {
                    CheckCompanionsForChanges(companions);
                    _pluginLog.Debug($"Shared {companions.Count} companion mods for {ownerName}");
                }
            }
            catch
            {
                // Swallow exception
            }
        }

        private string CalculateModDataHash(AdvancedPlayerInfo playerInfo)
        {
            var hashData = new
            {
                Mods = (playerInfo.Mods ?? new List<string>()).OrderBy(x => x).ToList(),
                GlamourerDesign = playerInfo.GlamourerDesign?.Trim() ?? "",
                CustomizePlusProfile = playerInfo.CustomizePlusProfile?.Trim() ?? "",
                HonorificTitle = playerInfo.HonorificTitle?.Trim() ?? "",
                SimpleHeelsOffset = Math.Round(playerInfo.SimpleHeelsOffset ?? 0.0f, 3)
            };

            var json = JsonSerializer.Serialize(hashData);
            using var sha256 = SHA256.Create();
            var hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(json));
            return Convert.ToHexString(hashBytes)[..16]; // 16-char hash for phonebook
        }

        private void OnCommand(string command, string args)
        {
            if (string.IsNullOrEmpty(args))
            {
                _configWindow.Toggle();
                return;
            }

            var parts = args.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length >= 1)
            {
                var subcommand = parts[0].ToLower();

                switch (subcommand)
                {
                    case "redraw":
                        if (parts.Length >= 2)
                        {
                            var playerName = parts[1];
                            _redrawCoordinator.RedrawCharacterIfFound(playerName);
                        }
                        else
                        {
                            _redrawCoordinator.RequestRedrawAll(RedrawReason.ManualRefresh);
                        }
                        break;
                    case "block":
                        if (parts.Length >= 2)
                        {
                            var playerName = parts[1];
                            BlockUser(playerName);
                        }
                        break;
                    case "unblock":
                        if (parts.Length >= 2)
                        {
                            var playerName = parts[1];
                            UnblockUser(playerName);
                        }
                        break;
                    case "testuser":
                        if (parts.Length >= 2)
                        {
                            var playerName = parts[1];
                            TestBlockUser(playerName);
                        }
                        break;
                    case "debug":
                        _pluginLog.Info("=== Debug: Logging all object types ===");
                        DebugLogObjectTypes();
                        break;
                    case "recovery":
                        _ = Task.Run(HandlePluginRecovery);
                        break;
                    case "clearmembers":
                        if (parts.Length >= 2)
                        {
                            var syncshellName = parts[1];
                            var syncshell = _syncshellManager.GetSyncshells().FirstOrDefault(s => s.Name.Equals(syncshellName, StringComparison.OrdinalIgnoreCase));
                            if (syncshell != null)
                            {
                                _syncshellManager.ClearSyncshellMembers(syncshell.Id);
                                SaveConfiguration();
                                _pluginLog.Info($"Cleared member list for syncshell '{syncshellName}'");
                            }
                            else
                            {
                                _pluginLog.Warning($"Syncshell '{syncshellName}' not found");
                            }
                        }
                        break;
                    default:
                        _configWindow.Toggle();
                        break;
                }
            }
            else
            {
                _configWindow.Toggle();
            }
        }

        private void DebugLogObjectTypes()
        {
            _framework.RunOnFrameworkThread(() =>
            {
                try
                {
                    var objects = _objectTable.Where(obj => obj != null).GroupBy(obj => obj.ObjectKind).ToList();
                    foreach (var group in objects)
                    {
                        _pluginLog.Info($"{group.Key}: {group.Count()} objects");
                    }
                }
                catch
                {
                    // Swallow exception
                }
            });
        }

        public void Dispose()
        {
            try
            {
                // Cancel all operations first
                _cancellationTokenSource.Cancel();
                
                // Remove framework handlers immediately
                _framework.Update -= OnFrameworkUpdate;
                _pluginInterface.UiBuilder.Draw -= _windowSystem.Draw;
                _pluginInterface.UiBuilder.OpenConfigUi -= () => _configWindow.Toggle();
                _commandManager.RemoveHandler(CommandName);
                _windowSystem.RemoveAllWindows();
                
                // Force immediate disposal without waiting
                try { _turnManager?.Dispose(); } catch { }
                try { _syncshellManager?.Dispose(); } catch { }
                try { _modSyncOrchestrator?.Dispose(); } catch { }
                try { _clientCache?.Dispose(); } catch { }
                try { _componentCache?.Dispose(); } catch { }
                try { _syncQueueProcessor?.Dispose(); } catch { }
                try { _syncProcessingSemaphore?.Dispose(); } catch { }
                try { _httpClient?.Dispose(); } catch { }
                try { _cancellationTokenSource.Dispose(); } catch { }
                
                // Unsubscribe from mod system events (best effort)
                try
                {
                    _penumbraModSettingChanged?.Unsubscribe((string _) => OnModSystemChanged());
                    _glamourerStateChanged?.Unsubscribe(() => OnModSystemChanged());
                    _customizePlusProfileChanged?.Unsubscribe(() => OnModSystemChanged());
                    _heelsOffsetChanged?.Unsubscribe(() => OnModSystemChanged());
                    _honorificChanged?.Unsubscribe(() => OnModSystemChanged());
                }
                catch { }
            }
            catch { }
        }

        // Cache methods
        private async Task ApplyPlayerModsFromCache(string playerName, CachedPlayerMods cachedMods)
        {
            if (cachedMods != null)
            {
                // Attempt component-based reconstruction if available
                if (_componentCache != null && cachedMods.ComponentData != null)
                {
                    await _componentCache.ApplyComponentToPlayer(playerName, cachedMods.ComponentData);
                }
                else if (_componentCache != null)
                {
                    // Fallback: try reconstructing from any stored recipe for this player
                    var reconstructed = await _componentCache.GetCachedAppearanceRecipe(playerName);
                    if (reconstructed != null)
                    {
                        await _modSystemIntegration.ApplyPlayerMods(reconstructed, playerName);
                    }
                }

                // Fallback to client-cache content if present
                if (_clientCache != null && (cachedMods.RecipeData != null || (cachedMods.Mods?.Count > 0)))
                {
                    await ApplyModsFromClientCache(playerName, cachedMods);
                }
                _pluginLog.Info($"Applied cached mods for {playerName}");
            }
        }

        // Apply mods using data from the client cache (recipe or reconstructed minimal info)
        private async Task ApplyModsFromClientCache(string playerName, CachedPlayerMods cachedMods)
        {
            try
            {
                // Prefer full AdvancedPlayerInfo if available
                if (cachedMods.RecipeData is AdvancedPlayerInfo apiInfo)
                {
                    await _modSystemIntegration.ApplyPlayerMods(apiInfo, playerName);
                    return;
                }

                // If RecipeData is JSON, try to deserialize to AdvancedPlayerInfo
                if (cachedMods.RecipeData is System.Text.Json.JsonElement jsonElement)
                {
                    try
                    {
                        var deserialized = jsonElement.Deserialize<AdvancedPlayerInfo>(new System.Text.Json.JsonSerializerOptions
                        {
                            PropertyNameCaseInsensitive = true
                        });
                        if (deserialized != null)
                        {
                            await _modSystemIntegration.ApplyPlayerMods(deserialized, playerName);
                            return;
                        }
                    }
                    catch { /* ignore and continue to fallback */ }
                }
                else if (cachedMods.RecipeData is string jsonStr && !string.IsNullOrWhiteSpace(jsonStr))
                {
                    try
                    {
                        var deserialized = System.Text.Json.JsonSerializer.Deserialize<AdvancedPlayerInfo>(jsonStr, new System.Text.Json.JsonSerializerOptions
                        {
                            PropertyNameCaseInsensitive = true
                        });
                        if (deserialized != null)
                        {
                            await _modSystemIntegration.ApplyPlayerMods(deserialized, playerName);
                            return;
                        }
                    }
                    catch { /* ignore and continue to fallback */ }
                }

                // Minimal fallback: use cached mod names (may be limited if paths are unknown)
                if (cachedMods.Mods != null && cachedMods.Mods.Count > 0)
                {
                    var minimal = new AdvancedPlayerInfo
                    {
                        PlayerName = playerName,
                        Mods = cachedMods.Mods
                            .Select(m => m.ModInfo?.ModName)
                            .Where(n => !string.IsNullOrEmpty(n))
                            .Distinct()
                            .ToList()!
                    };

                    await _modSystemIntegration.ApplyPlayerMods(minimal, playerName);
                    return;
                }

                _pluginLog.Debug($"Client-cache had no usable recipe for {playerName}");
            }
            catch (Exception ex)
            {
                _pluginLog.Warning($"Client-cache apply failed for {playerName}: {ex.Message}");
            }
        }

        private void CheckPlayersForChanges(List<PlayerSnapshot> nearbyPlayers)
        {
            foreach (var player in nearbyPlayers)
            {
                // Check network phonebook for peer changes
                var phonebookEntry = _syncshellManager.GetPhonebookEntry(player.Name);
                if (phonebookEntry != null)
                {
                    // Get mod data from separate mapping
                    var modData = _syncshellManager.GetPlayerModData(player.Name);
                    if (modData != null)
                    {
                        if (_componentCache != null && modData.ComponentData != null)
                        {
                            _componentCache.UpdateComponentForPlayer(player.Name, modData.ComponentData);
                        }
                        if (_clientCache != null && modData.RecipeData != null)
                        {
                            _clientCache.UpdateRecipeForPlayer(player.Name, modData.RecipeData);
                        }
                        _pluginLog.Info($"Updated cache for {player.Name} from mod data");
                    }
                }
            }
        }

        private void CheckCompanionsForChanges(List<CompanionSnapshot> companions)
        {
            foreach (var companion in companions)
            {
                // Check network phonebook for companion peer info
                var phonebookEntry = _syncshellManager.GetPhonebookEntry(companion.Name);
                if (phonebookEntry != null)
                {
                    // Get companion mod data from separate mapping
                    var modData = _syncshellManager.GetPlayerModData(companion.Name);
                    if (modData?.ComponentData != null && _componentCache != null)
                    {
                        _componentCache.UpdateComponentForPlayer(companion.Name, modData.ComponentData);
                        _pluginLog.Info($"Updated companion cache for {companion.Name} from mod data");
                    }
                }
                else
                {
                    ShareCompanionToSyncshells(companion);
                }
            }
        }

        private void ShareCompanionToSyncshells(CompanionSnapshot companion)
        {
            _ = Task.Run(async () =>
            {
                try
                {
                    var companionInfo = await _modSystemIntegration.GetCurrentPlayerMods(companion.Name);
                    if (companionInfo != null)
                    {
                        var companionHash = CalculateModDataHash(companionInfo);
                        var activeSyncshells = _syncshellManager.GetSyncshells().Where(s => s.IsActive);
                        foreach (var syncshell in activeSyncshells)
                        {
                            var companionData = new
                            {
                                type = "companion",
                                companionName = companion.Name,
                                objectKind = companion.ObjectKind,
                                outfitHash = companionHash,
                                mods = companionInfo.Mods,
                                timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
                            };
                            var json = JsonSerializer.Serialize(companionData);
                            await _syncshellManager.SendModData(syncshell.Id, json);
                        }
                    }
                }
                catch
                {
                    // Swallow exception
                }
            });
        }

        private void DisposeClientCache()
        {
            try
            {
                _clientCache?.Dispose();
                _componentCache?.Dispose();
            }
            catch (Exception ex)
            {
                _pluginLog.Error($"Error disposing caches: {ex.Message}");
            }
        }

        /// <summary>
        /// Get comprehensive cache statistics showing deduplication efficiency.
        /// </summary>
        public string GetCacheStatsDisplay()
        {
            if (_clientCache == null && _componentCache == null)
                return "Cache: Disabled";
            
            var parts = new List<string>();
            
            if (_clientCache != null)
            {
                var clientStats = _clientCache.GetCacheStats();
                parts.Add($"Players: {clientStats.TotalPlayers}, Mods: {clientStats.TotalMods}, Size: {FormatBytes(clientStats.TotalSizeBytes)}");
            }
            
            if (_componentCache != null)
            {
                var componentStats = _componentCache.GetCacheStats();
                // Prefer new naming TotalComponents/TotalRecipes, fallback to legacy if zeros
                var components = componentStats.TotalComponents != 0 ? componentStats.TotalComponents : componentStats.ComponentCount;
                var recipes = componentStats.TotalRecipes != 0 ? componentStats.TotalRecipes : componentStats.RecipeCount;
                parts.Add($"Components: {components}, Recipes: {recipes}");
            }
            
            return string.Join(" | ", parts);
        }
        
        private string FormatBytes(long bytes)
        {
            string[] sizes = { "B", "KB", "MB", "GB" };
            double len = bytes;
            int order = 0;
            while (len >= 1024 && order < sizes.Length - 1)
            {
                order++;
                len = len / 1024;
            }
            return $"{len:0.##} {sizes[order]}";
        }

        /// <summary>
        /// Log detailed cache statistics for debugging.
        /// Shows the efficiency of the reference-based deduplication system.
        /// </summary>
        public void LogCacheStatistics()
        {
            try
            {
                if (_clientCache != null)
                {
                    var clientStats = _clientCache.GetClientDeduplicationStats();
                    _pluginLog.Info($"Client Cache Stats: {clientStats}");
                    _pluginLog.Info($"  - Traditional storage would need {clientStats.TotalReferences} files");
                    _pluginLog.Info($"  - Actual storage uses {clientStats.TotalModFiles} files");
                    _pluginLog.Info($"  - Average {clientStats.AverageReferencesPerMod:F1} references per mod file");
                }
                
                if (_componentCache != null)
                {
                    var componentStats = _componentCache.GetDeduplicationStats();
                    _pluginLog.Info($"Component Cache Stats: {componentStats}");
                    _pluginLog.Info($"  - {componentStats.TotalComponents} unique components shared across {componentStats.TotalRecipes} recipes");
                    _pluginLog.Info($"  - Average {componentStats.AverageReferencesPerComponent:F1} references per component");
                    
                    // Log component cache detailed statistics
                    _componentCache.LogStatistics();
                }
            }
            catch (Exception ex)
            {
                _pluginLog.Error($"Error logging cache statistics: {ex.Message}");
            }
        }

        // Debug & Utility Methods
        public void LogObjectType(object obj, string context = "")
        {
            var type = obj?.GetType()?.Name ?? "null";
            _pluginLog.Debug($"[{context}] Object type: {type}");
        }

        public void LogModApplicationDetails(string playerName, object modData)
        {
            LogObjectType(modData, $"ModData for {playerName}");
            var preview = modData?.ToString();
            if (preview != null && preview.Length > 100) preview = preview[..100] + "...";
            _pluginLog.Debug($"Applying mods to {playerName}: {preview}");
        }

        // Advanced Configuration & Recovery
        public void CleanupOldPlayerAssociations()
        {
            var cutoff = DateTime.UtcNow.AddHours(-24);
            var toRemove = _playerLastSeen.Where(kvp => kvp.Value < cutoff).Select(kvp => kvp.Key).ToList();
            
            foreach (var player in toRemove)
            {
                _playerLastSeen.TryRemove(player, out _);
                _playerSyncshellAssociations.TryRemove(player, out _);
                _loadingStates.TryRemove(player, out _);
            }
            
            if (toRemove.Count > 0)
            {
                _pluginLog.Info($"Cleaned up {toRemove.Count} old player associations");
            }
        }

        public async Task RetryDetection()
        {
            _pluginLog.Info("Retrying mod system detection...");
            CheckModSystemAvailability();
            await Task.Delay(1000);
        }

        public async Task HandlePluginRecovery()
        {
            _pluginLog.Info("Starting plugin recovery sequence...");
            
            try
            {
                CleanupOldPlayerAssociations();
                await RetryDetection();
                
                if (_clientCache == null) InitializeClientCache();
                if (_componentCache == null) InitializeComponentCache();
                
                await PerformPeerDiscovery();
                
                _pluginLog.Info("Plugin recovery completed");
            }
            catch
            {
                _pluginLog.Error($"Plugin recovery failed");
            }
        }
        
        private bool _p2pMessageHandlingWired = false;
        
        public void WireUpP2PMessageHandling(string syncshellId)
        {
            if (_p2pMessageHandlingWired)
            {
                _pluginLog.Info($"[P2P] Message handling already wired up, skipping duplicate for syncshell {syncshellId}");
                return;
            }
            
            _pluginLog.Info($"[P2P] ✅ Wiring up message handling for syncshell {syncshellId}");
            
            // Set local player name for filtering
            var localPlayerName = _clientState.LocalPlayer?.Name?.TextValue;
            if (!string.IsNullOrEmpty(localPlayerName))
            {
                _syncshellManager.SetLocalPlayerName(localPlayerName);
                _pluginLog.Info($"[P2P] Set local player name for filtering: {localPlayerName}");
            }
            else
            {
                _pluginLog.Warning("[P2P] Could not get local player name for filtering");
            }
            
            // Wire up the SyncshellManager event handler (only once)
            _syncshellManager.WireUpModDataHandler(async (playerName, modData) => {
                _pluginLog.Info($"[P2P] 🎯 EVENT FIRED: Processing mod data for: {playerName}");
                _pluginLog.Info($"[P2P] 🎯 EVENT FIRED: ModData type: {modData.ValueKind}, Raw text length: {modData.GetRawText().Length}");
                await ProcessReceivedModData(playerName, modData);
            });
            
            // Also try to wire up RobustWebRTCConnection events if available
            var connection = _syncshellManager.GetWebRTCConnection(syncshellId);
            if (connection is RobustWebRTCConnection robustConnection)
            {
                robustConnection.OnPhonebookUpdated += (players) => {
                    _pluginLog.Info($"[P2P] Phonebook updated with {players.Count} players");
                    foreach (var player in players)
                    {
                        _recentlySyncedUsers.TryAdd(player, 0);
                    }
                    SaveConfiguration();
                };
                
                _pluginLog.Info($"[P2P] 🎯 IMMEDIATE: RobustWebRTCConnection events wired up for syncshell {syncshellId}");
            }
            
            _p2pMessageHandlingWired = true;
            _pluginLog.Info($"[P2P] ✅ Message handling successfully wired up for syncshell {syncshellId}");
        }
        
        private async Task ProcessReceivedModData(string playerName, JsonElement modData)
        {
            try
            {
                _pluginLog.Info($"🎯 [P2P MOD PROCESSING] Processing received mod data for {playerName}");
                _pluginLog.Info($"🎯 [P2P MOD PROCESSING] Raw JSON size: {modData.GetRawText().Length} characters");
                
                // Log the structure of the received data
                _pluginLog.Info($"🎯 [P2P MOD PROCESSING] JSON properties available:");
                foreach (var property in modData.EnumerateObject())
                {
                    var valueType = property.Value.ValueKind.ToString();
                    var valuePreview = property.Value.ValueKind == JsonValueKind.Array ? 
                        $"Array[{property.Value.GetArrayLength()}]" : 
                        property.Value.ToString();
                    if (valuePreview.Length > 50) valuePreview = valuePreview[..50] + "...";
                    _pluginLog.Info($"🎯 [P2P MOD PROCESSING]   - {property.Name}: {valueType} = {valuePreview}");
                }
                
                // Extract mod components with detailed logging - check both direct and nested formats
                var mods = new List<string>();
                
                // First try direct 'mods' property
                if (modData.TryGetProperty("mods", out var modsProperty))
                {
                    _pluginLog.Info($"🎯 [P2P MOD PROCESSING] Found direct 'mods' property with {modsProperty.GetArrayLength()} items");
                    var modIndex = 0;
                    foreach (var mod in modsProperty.EnumerateArray())
                    {
                        var modPath = mod.GetString();
                        if (!string.IsNullOrEmpty(modPath))
                        {
                            mods.Add(modPath);
                            if (modIndex < 5) // Log first 5 mods for debugging
                            {
                                _pluginLog.Info($"🎯 [P2P MOD PROCESSING]   [{modIndex}]: {modPath}");
                            }
                        }
                        modIndex++;
                    }
                    if (mods.Count > 5)
                    {
                        _pluginLog.Info($"🎯 [P2P MOD PROCESSING]   ... and {mods.Count - 5} more mods");
                    }
                }
                // Try nested format: componentData.mods
                else if (modData.TryGetProperty("componentData", out var componentDataProperty) &&
                         componentDataProperty.TryGetProperty("mods", out var nestedModsProperty))
                {
                    _pluginLog.Info($"🎯 [P2P MOD PROCESSING] Found nested 'componentData.mods' property with {nestedModsProperty.GetArrayLength()} items");
                    var modIndex = 0;
                    foreach (var mod in nestedModsProperty.EnumerateArray())
                    {
                        var modPath = mod.GetString();
                        if (!string.IsNullOrEmpty(modPath))
                        {
                            mods.Add(modPath);
                            if (modIndex < 5) // Log first 5 mods for debugging
                            {
                                _pluginLog.Info($"🎯 [P2P MOD PROCESSING]   [{modIndex}]: {modPath}");
                            }
                        }
                        modIndex++;
                    }
                    if (mods.Count > 5)
                    {
                        _pluginLog.Info($"🎯 [P2P MOD PROCESSING]   ... and {mods.Count - 5} more mods");
                    }
                }
                else
                {
                    _pluginLog.Warning($"🎯 [P2P MOD PROCESSING] No 'mods' property found in received data (checked both direct and componentData.mods)");
                }
                
                // Extract other mod data - try both direct and nested formats
                var glamourerDesign = GetStringProperty(modData, "glamourerDesign") ?? 
                                    GetNestedStringProperty(modData, "componentData", "glamourerDesign");
                    
                var customizePlusProfile = GetStringProperty(modData, "customizePlusProfile") ?? 
                                         GetNestedStringProperty(modData, "componentData", "customizePlusProfile");
                    
                var simpleHeelsOffset = GetFloatProperty(modData, "simpleHeelsOffset") ?? 
                                      GetNestedFloatProperty(modData, "componentData", "simpleHeelsOffset");
                    
                var honorificTitle = GetStringProperty(modData, "honorificTitle") ?? 
                                   GetNestedStringProperty(modData, "componentData", "honorificTitle");
                    
                var outfitHash = modData.TryGetProperty("outfitHash", out var hashProperty) ? 
                    hashProperty.GetString() : null;
                
                _pluginLog.Info($"🎯 [P2P MOD PROCESSING] EXTRACTION SUMMARY for {playerName}:");
                _pluginLog.Info($"🎯 [P2P MOD PROCESSING]   - Mods extracted: {mods.Count}");
                _pluginLog.Info($"🎯 [P2P MOD PROCESSING]   - Glamourer: {!string.IsNullOrEmpty(glamourerDesign)}");
                _pluginLog.Info($"🎯 [P2P MOD PROCESSING]   - Customize+: {!string.IsNullOrEmpty(customizePlusProfile)}");
                _pluginLog.Info($"🎯 [P2P MOD PROCESSING]   - Heels: {simpleHeelsOffset}");
                _pluginLog.Info($"🎯 [P2P MOD PROCESSING]   - Honorific: {!string.IsNullOrEmpty(honorificTitle)}");
                _pluginLog.Info($"🎯 [P2P MOD PROCESSING]   - Hash: {outfitHash?[..8] ?? "none"}");
                
                // Create comprehensive player inforehensive player info
                var playerInfo = new AdvancedPlayerInfo
                {
                    PlayerName = playerName,
                    Mods = mods,
                    GlamourerData = glamourerDesign,
                    CustomizePlusData = customizePlusProfile,
                    SimpleHeelsOffset = simpleHeelsOffset,
                    HonorificTitle = honorificTitle
                };
                
                // Store in caches
                if (_componentCache != null && !string.IsNullOrEmpty(outfitHash))
                {
                    await _componentCache.StoreAppearanceRecipe(playerName, outfitHash, playerInfo);
                    _pluginLog.Info($"[P2P] Stored appearance recipe in component cache for {playerName}");
                }
                
                if (_clientCache != null)
                {
                    _clientCache.UpdateRecipeForPlayer(playerName, playerInfo);
                    _pluginLog.Info($"[P2P] Updated client cache for {playerName}");
                }
                
                // Apply mods with enhanced logging
                _pluginLog.Info($"🎯 [P2P MOD PROCESSING] Applying mods to {playerName} via mod integration system...");
                var success = await _modSystemIntegration.ApplyPlayerMods(playerInfo, playerName);
                if (success)
                {
                    _pluginLog.Info($"🎯 [P2P MOD PROCESSING] ✅ Successfully applied and cached mods for: {playerName}");
                    _loadingStates[playerName] = LoadingState.Complete;
                    _recentlySyncedUsers.TryAdd(playerName, 0);
                    SaveConfiguration(); // Save to persist recently synced users
                    
                    // Trigger redraw
                    _pluginLog.Info($"🎯 [P2P MOD PROCESSING] Triggering character redraw for {playerName}");
                    _redrawCoordinator.RedrawCharacterIfFound(playerName);
                }
                else
                {
                    _pluginLog.Warning($"🎯 [P2P MOD PROCESSING] ❌ Failed to apply mods for {playerName} - mod integration returned false");
                }
            }
            catch (Exception ex)
            {
                _pluginLog.Error($"🎯 [P2P MOD PROCESSING] Failed to process mod data for {playerName}: {ex.Message}");
                _pluginLog.Error($"🎯 [P2P MOD PROCESSING] Stack trace: {ex.StackTrace}");
            }
        }
        
        // Helper methods for extracting properties from nested JSON
        private static string? GetStringProperty(JsonElement element, string propertyName)
        {
            return element.TryGetProperty(propertyName, out var prop) ? prop.GetString() : null;
        }
        
        private static string? GetNestedStringProperty(JsonElement element, string parentProperty, string childProperty)
        {
            return element.TryGetProperty(parentProperty, out var parent) && 
                   parent.TryGetProperty(childProperty, out var child) ? child.GetString() : null;
        }
        
        private static float? GetFloatProperty(JsonElement element, string propertyName)
        {
            return element.TryGetProperty(propertyName, out var prop) ? (float?)prop.GetSingle() : null;
        }
        
        private static float? GetNestedFloatProperty(JsonElement element, string parentProperty, string childProperty)
        {
            return element.TryGetProperty(parentProperty, out var parent) && 
                   parent.TryGetProperty(childProperty, out var child) ? (float?)child.GetSingle() : null;
        }


    }

    public class ConfigWindow : Window
    {
        private readonly FyteClubPlugin _plugin;
        private string _newSyncshellName = "";
        private string _inviteCode = "";
        // Manual answer code fields removed - using Nostr signaling

        private DateTime _lastCopyTime = DateTime.MinValue;
        private int _lastCopiedIndex = -1;
        private bool? _webrtcAvailable = null;
        private DateTime _lastWebrtcTest = DateTime.MinValue;
        private string _blockPlayerName = "";
        
        // TURN hosting tab fields
        private bool _enableTurnHosting = false;
        private string _turnTestStatus = "";
        private bool _isTurnTesting = false;
        private Vector4 _turnStatusColor = new(1, 1, 1, 1);
        private bool _showSetupGuide = false;
        private string _localIP = "";
        private string _routerIP = "";
        private string _portInputText = "";


        public ConfigWindow(FyteClubPlugin plugin) : base("FyteClub - P2P Mod Sharing")
        {
            _plugin = plugin;
            SizeConstraints = new WindowSizeConstraints
            {
                MinimumSize = new Vector2(400, 300),
                MaximumSize = new Vector2(800, 600)
            };
            
            _enableTurnHosting = _plugin._turnManager.IsHostingEnabled;
        }
        


        public override void Draw()
        {
            if (ImGui.BeginTabBar("FyteClubTabs"))
            {
                if (ImGui.BeginTabItem("Syncshells"))
                {
                    DrawSyncshellsTab();
                    ImGui.EndTabItem();
                }
                
                if (ImGui.BeginTabItem("Block List"))
                {
                    DrawBlockListTab();
                    ImGui.EndTabItem();
                }
                
                if (ImGui.BeginTabItem("Cache"))
                {
                    DrawCacheTab();
                    ImGui.EndTabItem();
                }
                
                if (ImGui.BeginTabItem("Routing Server"))
                {
                    DrawTurnHostingTab();
                    ImGui.EndTabItem();
                }
                
                if (ImGui.BeginTabItem("Logging"))
                {
                    DrawLoggingTab();
                    ImGui.EndTabItem();
                }
                
                ImGui.EndTabBar();
            }
        }
        
        private void DrawSyncshellsTab()
        {
            var syncshells = _plugin.GetSyncshells();
            var activeSyncshells = syncshells.Count(s => s.IsActive);
            
            ImGui.TextColored(activeSyncshells > 0 ? new Vector4(0, 1, 0, 1) : new Vector4(1, 0, 0, 1), 
                $"Active Syncshells: {activeSyncshells}/{syncshells.Count}");
            
            // Check for stale syncshells
            var staleSyncshells = syncshells.Where(s => s.IsStale).ToList();
            if (staleSyncshells.Count > 0)
            {
                ImGui.TextColored(new Vector4(1, 0.5f, 0, 1), $"⚠️ {staleSyncshells.Count} syncshells need bootstrap (30+ days old)");
            }
            
            ImGui.Separator();
            ImGui.Text("Create New Syncshell:");
            ImGui.InputText("Syncshell Name##create", ref _newSyncshellName, 50);
            
            if (ImGui.Button("Create Syncshell"))
            {
                if (!string.IsNullOrEmpty(_newSyncshellName))
                {
                    var capturedName = _newSyncshellName;
                    _newSyncshellName = "";
                    
                    _ = Task.Run(async () => 
                    {
                        try
                        {
                            await _plugin.CreateSyncshell(capturedName);
                        }
                        catch
                        {
                            // Error logged by plugin
                        }
                    });
                }
            }
            
            ImGui.Separator();
            ImGui.Text("Join Syncshell:");
            ImGui.InputText("Invite Code", ref _inviteCode, 2000);
            
            if (ImGui.Button("Join Syncshell"))
            {
                if (!string.IsNullOrEmpty(_inviteCode))
                {
                    var capturedCode = _inviteCode;
                    _inviteCode = "";
                    
                    _ = Task.Run(async () =>
                    {
                        try
                        {
                            _plugin._pluginLog.Info($"Attempting to join via invite code: {capturedCode}");
                            var result = await _plugin._syncshellManager.JoinSyncshellByInviteCode(capturedCode);
                            switch (result)
                            {
                                case JoinResult.Success:
                                    _plugin._pluginLog.Info("Successfully joined syncshell via invite code");
                                    _plugin.SaveConfiguration();
                                    
                                    // CRITICAL: Wire up message handling IMMEDIATELY after join success
                                    // This ensures we can process data received during bootstrap
                                    var syncshells = _plugin.GetSyncshells();
                                    var joinedSyncshell = syncshells.LastOrDefault();
                                    if (joinedSyncshell != null)
                                    {
                                        _plugin._pluginLog.Info($"[P2P] IMMEDIATE: Wiring up message handling for joined syncshell {joinedSyncshell.Id}");
                                        
                                        // Must run on framework thread to access LocalPlayer
                                        await _plugin._framework.RunOnFrameworkThread(() => {
                                            _plugin.WireUpP2PMessageHandling(joinedSyncshell.Id);
                                        });
                                    }
                                    
                                    // Wait a moment for WebRTC processing to complete
                                    await Task.Delay(1000);
                                    
                                    // Establish initial P2P connection with host
                                    _plugin._pluginLog.Info($"About to establish P2P connection with code: {capturedCode}");
                                    await _plugin.EstablishInitialP2PConnection(capturedCode);
                                    _plugin._pluginLog.Info("P2P connection establishment completed");
                                    break;
                                case JoinResult.AlreadyJoined:
                                    _plugin._pluginLog.Info("You are already in this syncshell");
                                    break;
                                case JoinResult.InvalidCode:
                                    _plugin._pluginLog.Warning("Invalid invite code format");
                                    break;
                                case JoinResult.Failed:
                                    _plugin._pluginLog.Warning("Failed to join syncshell - invite code may be invalid or expired");
                                    break;
                            }
                        }
                        catch (Exception ex)
                        {
                            _plugin._pluginLog.Error($"Failed to join via invite: {ex.Message}");
                        }
                    });
                }
            }
            
            // Answer code UI removed - Nostr signaling handles exchange automatically
            
            ImGui.Separator();
            ImGui.Text("Your Syncshells:");
            for (int i = 0; i < syncshells.Count; i++)
            {
                var syncshell = syncshells[i];
                
                bool active = syncshell.IsActive;
                if (ImGui.Checkbox($"##syncshell_{i}", ref active))
                {
                    syncshell.IsActive = active;
                    _plugin.SaveConfiguration();
                }
                
                ImGui.SameLine();
                var statusColor = syncshell.IsStale ? new Vector4(1, 0.5f, 0, 1) : new Vector4(1, 1, 1, 1);
                var statusText = syncshell.IsStale ? " [STALE]" : "";
                ImGui.TextColored(statusColor, $"{syncshell.Name} ({syncshell.Members?.Count ?? 0} members){statusText}");
                
                ImGui.SameLine();
                
                // Test WebRTC availability (cached for 30 seconds)
                if (_webrtcAvailable == null || (DateTime.UtcNow - _lastWebrtcTest).TotalSeconds > 30)
                {
                    try
                    {
                        var testConnection = WebRTCConnectionFactory.CreateConnectionAsync(_plugin._turnManager).Result;
                        testConnection.Dispose();
                        _webrtcAvailable = true;
                    }
                    catch
                    {
                        _webrtcAvailable = false;
                    }
                    _lastWebrtcTest = DateTime.UtcNow;
                }
                
                bool webrtcAvailable = _webrtcAvailable.Value;
                
                if (!webrtcAvailable)
                {
                    ImGui.BeginDisabled();
                }
                
                // Check if we have existing connections for this syncshell
                var hasConnections = _plugin._syncshellManager.GetSyncshells()
                    .Any(s => s.Id == syncshell.Id && s.Members?.Count > 1);
                
                // Show bootstrap button for stale syncshells
                if (syncshell.IsStale)
                {
                    if (ImGui.SmallButton($"Bootstrap##bootstrap_{i}"))
                    {
                        try
                        {
                            _ = Task.Run(async () => {
                                var bootstrapCode = await _plugin._syncshellManager.CreateBootstrapCode(syncshell.Id, _plugin._turnManager);
                                ImGui.SetClipboardText(bootstrapCode);
                                _plugin._pluginLog.Info($"Copied bootstrap code for stale syncshell: {syncshell.Name}");
                            });
                        }
                        catch (Exception ex)
                        {
                            _plugin._pluginLog.Error($"Bootstrap code generation failed: {ex.Message}");
                        }
                    }
                    if (ImGui.IsItemHovered())
                    {
                        ImGui.SetTooltip("Last sync was 30+ days ago. Share this code with friends to rebuild connections.");
                    }
                    ImGui.SameLine();
                }
                
                if (ImGui.SmallButton($"Copy Invite Code##syncshell_{i}"))
                {
                    try
                    {
                        _ = Task.Run(async () => {
                            var inviteCode = await _plugin._syncshellManager.GenerateNostrInviteCode(syncshell.Id, _plugin._turnManager);
                            ImGui.SetClipboardText(inviteCode);
                            
                            if (inviteCode.StartsWith("BOOTSTRAP:"))
                            {
                                _plugin._pluginLog.Info($"Copied bootstrap invite: {syncshell.Name}");
                            }
                            else if (inviteCode.StartsWith("NOSTR:"))
                            {
                                _plugin._pluginLog.Info($"Copied Nostr invite (automatic connection): {syncshell.Name}");
                            }
                        });
                        _lastCopyTime = DateTime.UtcNow;
                        _lastCopiedIndex = i;
                    }
                    catch (Exception ex)
                    {
                        _plugin._pluginLog.Error($"Invite code generation failed for {syncshell.Name}: {ex.Message}");
                    }
                }
                
                // Manual invites removed - all invites use Nostr signaling
                
                if (!webrtcAvailable)
                {
                    ImGui.EndDisabled();
                    if (ImGui.IsItemHovered(ImGuiHoveredFlags.AllowWhenDisabled))
                    {
                        ImGui.SetTooltip("WebRTC not available - P2P connections disabled");
                    }
                }
                
                if (_lastCopiedIndex == i && (DateTime.UtcNow - _lastCopyTime).TotalSeconds < 2)
                {
                    ImGui.SameLine();
                    ImGui.TextColored(new Vector4(0, 1, 0, 1), "✓ Copied!");
                }
                
                ImGui.SameLine();
                if (ImGui.SmallButton($"Leave##syncshell_{i}"))
                {
                    _plugin.RemoveSyncshell(syncshell.Id);
                    break;
                }
            }
            
            if (syncshells.Count == 0)
            {
                ImGui.Text("No syncshells yet. Create one to share mods with friends!");
            }
            
            // Manual answer exchange removed - Nostr signaling handles WebRTC automatically
            
            ImGui.Separator();
            if (ImGui.Button("Resync Mods"))
            {
                _plugin.RequestAllPlayerMods();
            }
            
            ImGui.SameLine();
            if (ImGui.Button("Resync My Appearance"))
            {
                _plugin.ShareMods();
            }
            
            ImGui.SameLine();
            if (ImGui.Button("Discover Peers"))
            {
                _plugin.ReconnectAllPeers();
            }
        }
        

        
        private void DrawBlockListTab()
        {
            ImGui.Text("Block Player:");
            ImGui.InputText("Player Name##block", ref _blockPlayerName, 100);
            ImGui.SameLine();
            if (ImGui.Button("Block"))
            {
                if (!string.IsNullOrEmpty(_blockPlayerName))
                {
                    _plugin.BlockUser(_blockPlayerName);
                    _blockPlayerName = "";
                }
            }
            
            ImGui.Separator();
            ImGui.Text("Recently Synced Players:");
            foreach (var player in _plugin.GetRecentlySyncedUsers())
            {
                ImGui.Text(player);
                ImGui.SameLine();
                if (_plugin.IsUserBlocked(player))
                {
                    if (ImGui.SmallButton($"Unblock##{player}"))
                    {
                        _plugin.UnblockUser(player);
                    }
                }
                else
                {
                    if (ImGui.SmallButton($"Block##{player}"))
                    {
                        _plugin.BlockUser(player);
                    }
                }
            }
        }
        
        private void DrawCacheTab()
        {
            ImGui.Text("Cache Statistics:");

            // Build display from actual cache instances
            var clientStats = _plugin.ClientCache?.GetCacheStats();
            var compSummary = _plugin.ComponentCache != null ? _componentCacheSummary() : "Component cache not initialized";

            if (clientStats != null)
            {
                ImGui.Text($"Players: {clientStats.TotalPlayers}");
                ImGui.Text($"Mods: {clientStats.TotalMods}");
                ImGui.Text($"Size: {clientStats.TotalSizeBytes / 1024.0 / 1024.0:0.##} MB");
                ImGui.Text($"Hit Rate: {clientStats.CacheHitRate:P0}");
            }
            else
            {
                ImGui.Text("Client cache not initialized");
            }

            ImGui.Text(compSummary);

            // ---- Per-player cache view ----
            ImGui.Separator();
            ImGui.Text("Per-Player Cache:");
            if (_plugin.ClientCache != null)
            {
                // Lazy init UI state
                _playerFilter ??= string.Empty;
                _selectedPlayer ??= string.Empty;

                ImGui.InputText("Filter##playerCacheFilter", ref _playerFilter, 100);
                ImGui.SameLine();
                ImGui.Text("Sort by:");
                ImGui.SameLine();
                ImGui.SetNextItemWidth(140);
                var sortLabels = new string[] { "Updated", "Size", "Mods", "Player" };
                ImGui.Combo("##playerSort", ref _playerSortIndex, sortLabels, sortLabels.Length);
                ImGui.SameLine();
                ImGui.Checkbox("Desc", ref _playerSortDesc);
                var summaries = _plugin.ClientCache.GetPlayerSummaries();
                if (!string.IsNullOrEmpty(_playerFilter))
                {
                    summaries = summaries
                        .Where(s => s.PlayerId.Contains(_playerFilter, StringComparison.OrdinalIgnoreCase))
                        .ToList();
                }
                // Apply sort
                IOrderedEnumerable<FyteClub.ClientModCache.PlayerCacheSummary> ordered = _playerSortIndex switch
                {
                    1 => (_playerSortDesc ? summaries.OrderByDescending(s => s.TotalSizeBytes) : summaries.OrderBy(s => s.TotalSizeBytes)),
                    2 => (_playerSortDesc ? summaries.OrderByDescending(s => s.ModCount) : summaries.OrderBy(s => s.ModCount)),
                    3 => (_playerSortDesc ? summaries.OrderByDescending(s => s.PlayerId) : summaries.OrderBy(s => s.PlayerId)),
                    _ => (_playerSortDesc ? summaries.OrderByDescending(s => s.LastUpdated) : summaries.OrderBy(s => s.LastUpdated)),
                };

                if (ImGui.BeginTable("PlayerCacheTable", 5, ImGuiTableFlags.Borders | ImGuiTableFlags.RowBg | ImGuiTableFlags.Resizable))
                {
                    ImGui.TableSetupColumn("Player");
                    ImGui.TableSetupColumn("Mods");
                    ImGui.TableSetupColumn("Size (MB)");
                    ImGui.TableSetupColumn("Last Updated");
                    ImGui.TableSetupColumn("Actions");
                    ImGui.TableHeadersRow();

                    foreach (var s in ordered)
                    {
                        ImGui.TableNextRow();
                        ImGui.TableNextColumn();
                        if (ImGui.Selectable(s.PlayerId, _selectedPlayer == s.PlayerId))
                        {
                            _selectedPlayer = s.PlayerId;
                        }
                        ImGui.TableNextColumn();
                        ImGui.Text(s.ModCount.ToString());
                        ImGui.TableNextColumn();
                        ImGui.Text($"{s.TotalSizeBytes / 1024.0 / 1024.0:0.##}");
                        ImGui.TableNextColumn();
                        ImGui.Text(s.LastUpdated.ToLocalTime().ToString("yyyy-MM-dd HH:mm"));
                        ImGui.TableNextColumn();
                        if (ImGui.SmallButton($"Clear##{s.PlayerId}"))
                        {
                            var pid = s.PlayerId; // capture
                            _ = Task.Run(async () => await _plugin.ClientCache.ClearPlayerCache(pid));
                        }
                    }
                    ImGui.EndTable();
                }

                // Details panel
                if (!string.IsNullOrEmpty(_selectedPlayer))
                {
                    var detail = _plugin.ClientCache.GetPlayerDetail(_selectedPlayer);
                    if (detail != null)
                    {
                        ImGui.Separator();
                        ImGui.Text($"Details for {_selectedPlayer} (mods: {detail.Mods.Count})");

                        if (ImGui.BeginTable("PlayerDetailTable", 7, ImGuiTableFlags.Borders | ImGuiTableFlags.RowBg | ImGuiTableFlags.Resizable))
                        {
                            ImGui.TableSetupColumn("Name");
                            ImGui.TableSetupColumn("Hash");
                            ImGui.TableSetupColumn("Size (KB)");
                            ImGui.TableSetupColumn("First Seen");
                            ImGui.TableSetupColumn("Last Accessed");
                            ImGui.TableSetupColumn("Refs");
                            ImGui.TableSetupColumn("Config");
                            ImGui.TableHeadersRow();

                            foreach (var m in detail.Mods.OrderByDescending(m => m.LastAccessed))
                            {
                                ImGui.TableNextRow();
                                ImGui.TableNextColumn(); ImGui.Text(m.Name);
                                ImGui.TableNextColumn();
                                ImGui.Text(m.ContentHash);
                                ImGui.SameLine();
                                if (ImGui.SmallButton($"Copy##{m.ContentHash}"))
                                {
                                    ImGui.SetClipboardText(m.ContentHash);
                                }
                                ImGui.TableNextColumn(); ImGui.Text($"{m.Size / 1024.0:0.##}");
                                ImGui.TableNextColumn(); ImGui.Text(m.FirstSeen.ToLocalTime().ToString("yyyy-MM-dd HH:mm"));
                                ImGui.TableNextColumn(); ImGui.Text(m.LastAccessed.ToLocalTime().ToString("yyyy-MM-dd HH:mm"));
                                ImGui.TableNextColumn(); ImGui.Text(m.ReferenceCount.ToString());
                                ImGui.TableNextColumn(); ImGui.Text(m.HasConfig ? "Yes" : "No");
                            }
                            ImGui.EndTable();
                        }
        
                        // Export helpers
                        if (ImGui.SmallButton("Copy Player Detail JSON"))
                        {
                            var json = _plugin.ClientCache.GetPlayerDetailJson(_selectedPlayer);
                            ImGui.SetClipboardText(json);
                        }
                        ImGui.SameLine();
                        if (ImGui.SmallButton("Copy Minimal Recipe"))
                        {
                            var recipe = _plugin.ClientCache.GetPlayerRecipeJson(_selectedPlayer) ?? "{}";
                            ImGui.SetClipboardText(recipe);
                        }
                    }
                }
            }
            
            ImGui.Separator();
            if (ImGui.Button("Log Cache Stats"))
            {
                _plugin.LogCacheStatistics();
            }
            
            ImGui.SameLine();
            if (ImGui.Button("Recovery"))
            {
                _ = Task.Run(_plugin.HandlePluginRecovery);
            }
            
            ImGui.SameLine();
            if (ImGui.Button("Clear All Cache"))
            {
                ImGui.OpenPopup("Confirm Clear Cache");
            }
            
            if (ImGui.BeginPopupModal("Confirm Clear Cache"))
            {
                ImGui.Text("Are you sure you want to clear all cached mod data?");
                if (ImGui.Button("Yes"))
                {
                    _ = Task.Run(async () =>
                    {
                        await (_plugin.ClientCache?.ClearAllCache() ?? Task.CompletedTask);
                        await (_plugin.ComponentCache?.ClearAllCache() ?? Task.CompletedTask);
                    });
                    ImGui.CloseCurrentPopup();
                }
                ImGui.SameLine();
                if (ImGui.Button("No"))
                {
                    ImGui.CloseCurrentPopup();
                }
                ImGui.EndPopup();
            }
        }

        // UI state for cache tab
        private string _playerFilter = string.Empty;
        private string _selectedPlayer = string.Empty;
        private int _playerSortIndex = 0; // 0=Updated,1=Size,2=Mods,3=Player
        private bool _playerSortDesc = true;

        private string _componentCacheSummary()
        {
            try
            {
                var stats = _plugin.ComponentCache?.GetStats();
                if (stats == null) return "Component cache not initialized";
                return $"Components: {stats.TotalComponents}, Recipes: {stats.TotalRecipes}, Size: {stats.TotalSizeBytes / 1024.0 / 1024.0:0.##} MB";
            }
            catch
            {
                return "Component cache stats unavailable";
            }
        }

        private void LogCacheStatistics()
        {
            try
            {
                var client = _plugin.ClientCache?.GetCacheStats();
                if (client != null)
                {
                    _plugin._pluginLog.Info($"[Cache] Players={client.TotalPlayers}, Mods={client.TotalMods}, Size={client.TotalSizeBytes} bytes, HitRate={client.CacheHitRate:P2}");
                }

                var comp = _plugin.ComponentCache?.GetStats();
                if (comp != null)
                {
                    _plugin._pluginLog.Info($"[ComponentCache] Components={comp.TotalComponents}, Recipes={comp.TotalRecipes}, Size={comp.TotalSizeBytes} bytes");
                }
            }
            catch (Exception ex)
            {
                _plugin._pluginLog.Warning($"Failed to log cache statistics: {ex.Message}");
            }
        }
        
        private void DrawTurnHostingTab()
        {
            var turnManager = _plugin._turnManager;
            if (turnManager == null)
            {
                ImGui.Text("TURN server manager not available");
                return;
            }
            
            ImGui.Text("🌐 Help Your Syncshell - Routing Server");
            ImGui.Separator();
            
            // Description
            ImGui.TextWrapped("What is this?");
            ImGui.TextWrapped("When enabled, your computer becomes a routing server to help your syncshell friends connect when direct connections fail. This improves connectivity for everyone in your group.");
            
            ImGui.Spacing();
            ImGui.TextWrapped("Privacy & Security:");
            ImGui.BulletText("Only your syncshell members can use your routing server");
            ImGui.BulletText("No personal data is stored or transmitted");
            ImGui.BulletText("Traffic is encrypted end-to-end");
            ImGui.BulletText("Automatically stops when you close FFXIV");
            
            ImGui.Spacing();
            ImGui.Separator();
            
            // Update state from manager
            _enableTurnHosting = turnManager.IsHostingEnabled;
            
            // Port configuration
            var config = _plugin.GetConfiguration();
            var configuredPort = config.TurnServerPort;
            var runningPort = turnManager.LocalServer?.Port;
            
            ImGui.Text($"Configured Port: {configuredPort}");
            if (runningPort.HasValue && runningPort != configuredPort)
            {
                ImGui.SameLine();
                ImGui.TextColored(new Vector4(1, 0.6f, 0.2f, 1), $"(Running: {runningPort})");
            }
            ImGui.SameLine();
            if (ImGui.SmallButton("Change Port"))
            {
                ImGui.OpenPopup("Configure Port");
                _portInputText = configuredPort.ToString();
            }
            
            if (ImGui.BeginPopup("Configure Port"))
            {
                ImGui.Text("Enter port number:");
                ImGui.InputText("##port", ref _portInputText, 10);
                
                ImGui.SameLine();
                if (ImGui.Button("Apply"))
                {
                    if (int.TryParse(_portInputText, out var newPort) && newPort >= 1024 && newPort <= 65535)
                    {
                        _plugin.UpdateTurnServerPort(newPort);
                        
                        // Restart TURN hosting if currently enabled
                        if (turnManager.IsHostingEnabled)
                        {
                            _ = Task.Run(async () => {
                                turnManager.DisableHosting();
                                await Task.Delay(500);
                                await turnManager.EnableHostingAsync(newPort);
                                _plugin._pluginLog.Info($"[TURN] Restarted hosting on new port {newPort}");
                            });
                        }
                        else
                        {
                            _plugin._pluginLog.Info($"[TURN] Port changed to {newPort} - will use on next hosting start");
                        }
                        
                        ImGui.CloseCurrentPopup();
                    }
                    else
                    {
                        _plugin._pluginLog.Warning($"[TURN] Invalid port: {_portInputText}. Must be 1024-65535");
                    }
                }
                
                ImGui.Spacing();
                ImGui.TextWrapped("Recommended ranges:");
                ImGui.BulletText("47000-49999: Gaming/P2P applications");
                ImGui.BulletText("Avoid: 49152-65535 (Windows ephemeral)");
                
                if (ImGui.Button("Use Smart Default (49000)"))
                {
                    _portInputText = "49000";
                }
                
                ImGui.EndPopup();
            }
            
            ImGui.Spacing();
            
            // Hosting controls
            if (ImGui.Checkbox("Enable Routing Server", ref _enableTurnHosting))
            {
                _ = Task.Run(async () => {
                    if (_enableTurnHosting)
                    {
                        var config = _plugin.GetConfiguration();
                        var success = await turnManager.EnableHostingAsync(config.TurnServerPort);
                        if (!success)
                        {
                            _enableTurnHosting = false;
                            _turnTestStatus = "❌ Failed to start routing server";
                            _turnStatusColor = new Vector4(1, 0.3f, 0.3f, 1);
                        }
                        else
                        {
                            _turnTestStatus = "✅ Routing server started successfully";
                            _turnStatusColor = new Vector4(0.3f, 1, 0.3f, 1);
                        }
                    }
                    else
                    {
                        turnManager.DisableHosting();
                        _turnTestStatus = "Routing server stopped";
                        _turnStatusColor = new Vector4(1, 1, 1, 1);
                    }
                });
            }
            
            if (_enableTurnHosting)
            {
                ImGui.SameLine();
                ImGui.TextColored(new Vector4(0.3f, 1, 0.3f, 1), "Active");
            }
            
            ImGui.Spacing();
            
            // Per-syncshell TURN hosting configuration
            if (_enableTurnHosting)
            {
                ImGui.Text("Enable routing for specific syncshells:");
                ImGui.Separator();
                
                var syncshells = _plugin.GetSyncshells();
                foreach (var syncshell in syncshells)
                {
                    bool enableForSyncshell = syncshell.EnableTurnHosting;
                    if (ImGui.Checkbox($"{syncshell.Name}##turn_{syncshell.Id}", ref enableForSyncshell))
                    {
                        syncshell.EnableTurnHosting = enableForSyncshell;
                        _plugin.SaveConfiguration();
                        
                        if (enableForSyncshell)
                        {
                            _plugin._pluginLog.Info($"[TURN] Enabled routing for syncshell: {syncshell.Name}");
                        }
                        else
                        {
                            _plugin._pluginLog.Info($"[TURN] Disabled routing for syncshell: {syncshell.Name}");
                        }
                    }
                    
                    ImGui.SameLine();
                    ImGui.TextColored(new Vector4(0.7f, 0.7f, 0.7f, 1), $"({syncshell.Members?.Count ?? 0} members)");
                }
                
                if (syncshells.Count == 0)
                {
                    ImGui.TextColored(new Vector4(0.7f, 0.7f, 0.7f, 1), "No syncshells available. Create a syncshell first.");
                }
                
                ImGui.Spacing();
            }
            
            // Connectivity test
            if (ImGui.Button("Test Connectivity"))
            {
                if (!_isTurnTesting)
                {
                    _ = Task.Run(async () => {
                        _isTurnTesting = true;
                        _turnTestStatus = "Running comprehensive connectivity test...";
                        _turnStatusColor = new Vector4(1, 1, 0.3f, 1);
                        
                        var results = new List<string>();
                        var hasErrors = false;
                        
                        try
                        {
                            var testPort = turnManager.LocalServer?.Port ?? 49878;
                            var server = turnManager.LocalServer;
                            
                            // 1. Check if TURN server is enabled
                            if (!turnManager.IsHostingEnabled)
                            {
                                results.Add("❌ TURN hosting is disabled");
                                hasErrors = true;
                            }
                            else
                            {
                                results.Add("✅ TURN hosting is enabled");
                            }
                            
                            // 2. Check if server is running
                            if (server == null)
                            {
                                results.Add("❌ TURN server is not running");
                                hasErrors = true;
                            }
                            else
                            {
                                results.Add($"✅ TURN server running on port {server.Port}");
                                results.Add($"✅ External IP detected: {server.ExternalIP}");
                            }
                            
                            // 3. Check if port is actually listening
                            var isListening = false;
                            try
                            {
                                var process = new System.Diagnostics.Process
                                {
                                    StartInfo = new System.Diagnostics.ProcessStartInfo
                                    {
                                        FileName = "netstat",
                                        Arguments = "-an",
                                        UseShellExecute = false,
                                        RedirectStandardOutput = true,
                                        CreateNoWindow = true
                                    }
                                };
                                process.Start();
                                var output = await process.StandardOutput.ReadToEndAsync();
                                process.WaitForExit();
                                
                                if (output.Contains($"UDP    0.0.0.0:{testPort}") || output.Contains($"UDP    *:{testPort}"))
                                {
                                    results.Add($"✅ Port {testPort} is listening locally");
                                    isListening = true;
                                }
                                else
                                {
                                    results.Add($"❌ Port {testPort} is NOT listening locally");
                                    hasErrors = true;
                                }
                            }
                            catch
                            {
                                results.Add("⚠️ Could not check if port is listening");
                            }
                            
                            // 4. Test TURN server response
                            if (isListening && server != null)
                            {
                                try
                                {
                                    using var testClient = new System.Net.Sockets.UdpClient();
                                    testClient.Client.ReceiveTimeout = 3000;
                                    
                                    // Send STUN binding request to our own server
                                    var stunRequest = new byte[] { 0x00, 0x01, 0x00, 0x00, 0x21, 0x12, 0xA4, 0x42, 
                                                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                                                                 0x00, 0x00, 0x00, 0x00 };
                                    
                                    await testClient.SendAsync(stunRequest, stunRequest.Length, "127.0.0.1", server.Port);
                                    var response = await testClient.ReceiveAsync();
                                    
                                    if (response.Buffer.Length >= 20 && response.Buffer[0] == 0x01 && response.Buffer[1] == 0x01)
                                    {
                                        results.Add("✅ TURN server responding to STUN requests");
                                    }
                                    else
                                    {
                                        results.Add($"⚠️ TURN server response invalid (got {response.Buffer.Length} bytes)");
                                    }
                                }
                                catch (Exception ex)
                                {
                                    results.Add($"❌ TURN server not responding: {ex.Message}");
                                    hasErrors = true;
                                }
                                
                                results.Add($"💡 Manual external test: https://www.ipvoid.com/udp-port-scan/");
                                results.Add($"   IP: {server.ExternalIP} Port: {server.Port}");
                            }
                            
                            // 5. Summary
                            if (!hasErrors && isListening)
                            {
                                results.Add("✅ All local checks passed! Your TURN server is working.");
                                results.Add("💡 If WebRTC still fails, check router port forwarding.");
                                _turnStatusColor = new Vector4(0.3f, 1, 0.3f, 1);
                            }
                            else if (hasErrors)
                            {
                                results.Add("❌ Issues found - check setup guide below");
                                _turnStatusColor = new Vector4(1, 0.3f, 0.3f, 1);
                            }
                            else
                            {
                                results.Add("⚠️ Partial success - may need router configuration");
                                _turnStatusColor = new Vector4(1, 0.6f, 0.2f, 1);
                            }
                            
                            _turnTestStatus = string.Join("\n", results);
                        }
                        catch (Exception ex)
                        {
                            _turnTestStatus = $"❌ Test failed: {ex.Message}";
                            _turnStatusColor = new Vector4(1, 0.3f, 0.3f, 1);
                        }
                        finally
                        {
                            _isTurnTesting = false;
                        }
                    });
                }
            }
            
            
            
            ImGui.SameLine();
            if (ImGui.Button("Setup Guide"))
            {
                _showSetupGuide = !_showSetupGuide;
            }
            
            if (_isTurnTesting)
            {
                ImGui.SameLine();
                ImGui.TextColored(new Vector4(1, 1, 0.3f, 1), "Testing...");
            }
            
            if (!string.IsNullOrEmpty(_turnTestStatus))
            {
                ImGui.Spacing();
                ImGui.TextColored(_turnStatusColor, _turnTestStatus);
            }
            
            if (_showSetupGuide)
            {
                ImGui.Spacing();
                ImGui.Separator();
                ImGui.TextColored(new Vector4(1, 1, 0.3f, 1), "🔧 Complete Setup Guide");
                
                var port = turnManager.LocalServer?.Port ?? 49878;
                
                // Get network info
                if (string.IsNullOrEmpty(_localIP) || string.IsNullOrEmpty(_routerIP))
                {
                    try
                    {
                        var host = System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostName());
                        _localIP = host.AddressList.FirstOrDefault(ip => ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)?.ToString() ?? "192.168.1.100";
                        
                        // Get actual default gateway
                        foreach (var ni in System.Net.NetworkInformation.NetworkInterface.GetAllNetworkInterfaces())
                        {
                            if (ni.OperationalStatus == System.Net.NetworkInformation.OperationalStatus.Up && ni.NetworkInterfaceType != System.Net.NetworkInformation.NetworkInterfaceType.Loopback)
                            {
                                var gateway = ni.GetIPProperties().GatewayAddresses.FirstOrDefault()?.Address;
                                if (gateway != null && gateway.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                                {
                                    _routerIP = gateway.ToString();
                                    break;
                                }
                            }
                        }
                        if (string.IsNullOrEmpty(_routerIP)) _routerIP = "192.168.1.1"; // fallback
                    }
                    catch { _localIP = "192.168.1.100"; _routerIP = "192.168.1.1"; }
                }
                
                ImGui.Text("Step 1: Fix Windows Firewall");
                ImGui.BulletText("Press Win+R, type 'cmd', press Ctrl+Shift+Enter (run as admin)");
                ImGui.BulletText("Copy and paste these commands:");
                
                var commands = $"netsh advfirewall firewall add rule name=\"FyteClub {port}\" dir=in action=allow protocol=UDP localport={port}";
                
                if (ImGui.Button("Copy Firewall Commands"))
                {
                    ImGui.SetClipboardText(commands);
                }
                ImGui.SameLine();
                ImGui.TextColored(new Vector4(0.7f, 0.7f, 0.7f, 1), "(copied to clipboard)");
                
                ImGui.Spacing();
                ImGui.Text("Step 2: Configure Router Port Forwarding");
                ImGui.BulletText($"Open your router admin page: http://{_routerIP}");
                if (ImGui.Button($"Copy Router Address: {_routerIP}"))
                {
                    ImGui.SetClipboardText(_routerIP);
                }
                ImGui.BulletText("Login (usually admin/admin or check router label)");
                ImGui.BulletText("Find 'Port Forwarding' settings (usually in Advanced section)");
                ImGui.BulletText("On Netgear Orbi: look for 'Add Custom Service' button");
                ImGui.BulletText($"Forward UDP port {port} to your PC: {_localIP}");
                
                if (ImGui.Button($"Copy Your PC IP: {_localIP}"))
                {
                    ImGui.SetClipboardText(_localIP);
                }
                ImGui.SameLine();
                if (ImGui.Button($"Copy Port: {port}"))
                {
                    ImGui.SetClipboardText(port.ToString());
                }
                
                ImGui.Spacing();
                ImGui.TextColored(new Vector4(0.3f, 1, 0.3f, 1), "Step 3: Test Connection");
                ImGui.BulletText("Click 'Test Connectivity' button above after completing steps 1-2");
                
                ImGui.Spacing();
                ImGui.TextColored(new Vector4(1, 0.6f, 0.2f, 1), "Still blocked? Try these:");
                ImGui.BulletText("Restart your router after adding port forwarding");
                ImGui.BulletText("Check if your ISP blocks incoming connections (CGNAT)");
                ImGui.BulletText("Try disabling Windows Defender temporarily");
                ImGui.BulletText("Some routers need 'Enable' checkbox for port forwarding rules");
                
                ImGui.Spacing();
                if (ImGui.Button("Hide Guide"))
                {
                    _showSetupGuide = false;
                }
            }
            
            ImGui.Spacing();
            ImGui.Separator();
            
            // Status
            if (turnManager.IsHostingEnabled && turnManager.LocalServer != null)
            {
                var server = turnManager.LocalServer;
                
                ImGui.Text("Server Status:");
                ImGui.BulletText($"External IP: {server.ExternalIP}");
                ImGui.BulletText($"Port: {server.Port}");
                ImGui.BulletText($"Status: Running");
                
                var serverCount = turnManager.AvailableServers.Count;
                ImGui.BulletText($"Other routing servers available: {serverCount}");
                
                if (serverCount > 0)
                {
                    ImGui.TextColored(new Vector4(0.3f, 1, 0.3f, 1), 
                        $"🌐 Great! Your syncshell has {serverCount + 1} routing servers total");
                }
                else
                {
                    ImGui.TextColored(new Vector4(1, 1, 0.3f, 1), "No other routing servers detected yet");
                }
            }
            else
            {
                ImGui.TextColored(new Vector4(0.7f, 0.7f, 0.7f, 1), "Not hosting");
            }
        }
        
        private void DrawLoggingTab()
        {
            ImGui.Text("Configure which logs to show for debugging");
            ImGui.Separator();

            // Master debug toggle
            var debugEnabled = FyteClub.Core.Logging.LoggingManager.IsDebugEnabled();
            if (ImGui.Checkbox("Enable Debug Logs", ref debugEnabled))
            {
                FyteClub.Core.Logging.LoggingManager.SetDebugEnabled(debugEnabled);
            }

            if (debugEnabled)
            {
                ImGui.Separator();
                ImGui.Text("Debug Log Modules:");
                
                var modules = FyteClub.Core.Logging.LoggingManager.GetAllModules();
                
                foreach (FyteClub.Core.Logging.LogModule module in Enum.GetValues<FyteClub.Core.Logging.LogModule>())
                {
                    var enabled = modules.GetValueOrDefault(module, false);
                    if (ImGui.Checkbox(module.ToString(), ref enabled))
                    {
                        FyteClub.Core.Logging.LoggingManager.SetModuleEnabled(module, enabled);
                    }
                    
                    // Add tooltips for clarity
                    if (ImGui.IsItemHovered())
                    {
                        var tooltip = module switch
                        {
                            FyteClub.Core.Logging.LogModule.Core => "Plugin lifecycle, syncshell creation/joining",
                            FyteClub.Core.Logging.LogModule.UI => "User interface interactions and updates",
                            FyteClub.Core.Logging.LogModule.WebRTC => "P2P connection establishment and data transfer",
                            FyteClub.Core.Logging.LogModule.Nostr => "Nostr relay communication and signaling",
                            FyteClub.Core.Logging.LogModule.Cache => "Mod data caching and storage",
                            FyteClub.Core.Logging.LogModule.ModSync => "Mod synchronization between players",
                            FyteClub.Core.Logging.LogModule.Syncshells => "Syncshell management and member lists",
                            FyteClub.Core.Logging.LogModule.TURN => "TURN server operations",
                            FyteClub.Core.Logging.LogModule.Penumbra => "Penumbra mod integration",
                            FyteClub.Core.Logging.LogModule.Glamourer => "Glamourer integration",
                            FyteClub.Core.Logging.LogModule.CustomizePlus => "Customize+ integration",
                            FyteClub.Core.Logging.LogModule.Heels => "Simple Heels integration",
                            FyteClub.Core.Logging.LogModule.Honorific => "Honorific integration",
                            _ => "Debug logs for this module"
                        };
                        ImGui.SetTooltip(tooltip);
                    }
                }
            }
            else
            {
                ImGui.TextDisabled("Enable debug logs to configure modules");
            }

            ImGui.Separator();
            ImGui.Text("Note: 'Always' level logs (critical events) are always shown");
        }
    }

    public enum LoadingState { None, Requesting, Downloading, Applying, Complete, Failed }

    public class Configuration : Dalamud.Configuration.IPluginConfiguration
    {
        public int Version { get; set; } = 0;
        public List<SyncshellInfo> Syncshells { get; set; } = new();
        public bool EncryptionEnabled { get; set; } = true;
        public int ProximityRange { get; set; } = 50;
        public List<string> BlockedUsers { get; set; } = new();
        public List<string> RecentlySyncedUsers { get; set; } = new();
        public bool EnableTurnHosting { get; set; } = false;
        public int TurnServerPort { get; set; } = 49000; // Default to safe range
    }

    public class PlayerSnapshot
    {
        public string Name { get; set; } = string.Empty;
        public uint ObjectIndex { get; set; }
        public nint Address { get; set; }
    }

    public class CompanionSnapshot
    {
        public string Name { get; set; } = string.Empty;
        public string ObjectKind { get; set; } = string.Empty;
        public uint ObjectIndex { get; set; }
    }
    
    public class SyncQueueEntry
    {
        public string PlayerName { get; set; } = string.Empty;
        public Vector3 Position { get; set; }
        public DateTime DetectedAt { get; set; }
        public float Priority { get; set; }
    }

    public class BootstrapConnectionInfo
    {
        public string PublicKey { get; set; } = string.Empty;
        public string IP { get; set; } = string.Empty;
        public int Port { get; set; }
    }

    public static class BootstrapKeyUtil
    {
        public static BootstrapConnectionInfo? Decode(string base64)
        {
            try
            {
                var json = System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(base64));
                return JsonSerializer.Deserialize<BootstrapConnectionInfo>(json);
            }
            catch
            {
                return null;
            }
        }
    }

}
